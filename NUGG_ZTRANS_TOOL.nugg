<?xml version="1.0" encoding="utf-16"?>
<nugget name="ZTRANS_TOOL">
 <CLAS CLSNAME="ZCL_REF_DDIC" VERSION="1" LANGU="S" DESCRIPT="References dictionary" UUID="E2C627A6F13BB1F191180050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_REF_DDIC" CMPNAME="TY_LIST_REFS" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="TY_LIST_REFS" TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCL_REF_DDIC" CMPNAME="TY_T_LIST_REFS" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="TY_T_LIST_REFS" TYPESRC_LENG="0 "/>
  <implementing CLSNAME="ZCL_REF_DDIC" REFCLSNAME="ZIF_REF_DATA" VERSION="1" EXPOSURE="2" STATE="1" AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" RELTYPE="1"/>
  <publicSection>class ZCL_REF_DDIC definition
  public
  create public .

*&quot;* public components of class ZCL_REF_DDIC
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .

  interfaces ZIF_REF_DATA .

  aliases DC_TYPE_STRUC
    for ZIF_REF_DATA~DC_TYPE_STRUC .
  aliases DC_TYPE_TABLE
    for ZIF_REF_DATA~DC_TYPE_TABLE .
  aliases TY_LIST_REFS
    for ZIF_REF_DATA~TY_LIST_REFS .
  aliases TY_T_LIST_REFS
    for ZIF_REF_DATA~TY_T_LIST_REFS .

  methods CONSTRUCTOR
    importing
      !I_OBJECT type ANY
      !I_TYPE type TROBJTYPE
      !I_LEVEL type I optional
      !I_ONLY_CUSTOMER_OBJ type SAP_BOOL default &apos;X&apos;
    exceptions
      ERROR_OBJECT
      TYPE_OBJECT_NOT_VALID .
  methods SEARCH_REFS
    exporting
      !E_REFS type ZIF_REF_DATA~TY_T_LIST_REFS .</publicSection>
  <protectedSection>*&quot;* protected components of class ZCL_REF_DDIC
*&quot;* do not include other source files here!!!
protected section.

  data D_OBJECT type DDOBJNAME .
  data D_TYPE type TROBJTYPE .
  data D_LEVEL type I .
  data IT_LIST_REFS type ZIF_REF_DATA~TY_T_LIST_REFS .
  data D_ONLY_CUSTOMER_OBJ type SAP_BOOL .

  methods GET_REF_DOMAIN .
  methods GET_REF_ROLLNAME .
  methods GET_REF_SEARCH_HELP .
  methods GET_REF_TABLE_TYPE .
  methods GET_REF_VIEW .
  methods GET_ALL_REFS .
  methods GET_REF_TABLE .</protectedSection>
  <privateSection>*&quot;* private components of class ZCL_REF_DDIC
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_REF_DDIC" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="DC_TYPE_STRUC" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="DC_TYPE_STRUC" R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="DC_TYPE_TABLE" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="DC_TYPE_TABLE" R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="D_LEVEL" VERSION="1" LANGU="S" DESCRIPT="Level for recursive references" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="D_OBJECT" VERSION="1" LANGU="S" DESCRIPT="object of string" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="D_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="S" DESCRIPT="Only customer object" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="D_TYPE" VERSION="1" LANGU="S" DESCRIPT="Tipo de objeto" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_DDIC" CMPNAME="IT_LIST_REFS" VERSION="1" LANGU="S" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="S" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20130529" MTDTYPE="2" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="I_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Name object of dictionary" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="I_TYPE" VERSION="1" LANGU="S" DESCRIPT="Tipo de objeto" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="I_LEVEL" VERSION="1" LANGU="S" DESCRIPT="Level for recursive references" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="I_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="S" DESCRIPT="Only customer objects" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SAP_BOOL" PARVALUE="&apos;X&apos;"/>
   <exception CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="ERROR_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Error in the object" MTDTYPE="2" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000"/>
   <exception CLSNAME="ZCL_REF_DDIC" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_OBJECT_NOT_VALID" VERSION="1" LANGU="S" DESCRIPT="The type of object is not valid" MTDTYPE="2" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000"/>
   <source>METHOD constructor.

  d_object = i_object.
  d_type = i_type.
  d_only_customer_obj = i_only_customer_obj.

  CASE i_type.
    WHEN zif_ref_data~dc_type_table
           OR zif_ref_data~dc_type_struc
           OR zif_ref_data~dc_type_dataelem
           OR zif_ref_data~dc_type_domain
           OR zif_ref_data~dc_type_tabltype
           OR zif_ref_data~dc_type_seahlp
           OR zif_ref_data~dc_type_view.
    WHEN OTHERS.
      RAISE type_object_not_valid.
  ENDCASE.

* El parametro I_LEVEL sirve para llamadas recursivas para encontrar referencias
* del objeto. Este nivel se guardara en la tabla de referencias con formato listado.
  IF i_level IS SUPPLIED.
    d_level = i_level.
  ELSE.
    d_level = 1.
  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_ALL_REFS" VERSION="1" LANGU="S" DESCRIPT="Get all references" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20130529" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_all_refs.

  CASE d_type.
    WHEN zif_ref_data~dc_type_table OR
         zif_ref_data~dc_type_struc.
      get_ref_table( ).
    WHEN zif_ref_data~dc_type_view.
      get_ref_view( ).
    WHEN zif_ref_data~dc_type_dataelem.
      get_ref_rollname( ).
    WHEN zif_ref_data~dc_type_domain.
      get_ref_domain( ).
    WHEN zif_ref_data~dc_type_tabltype.
      get_ref_table_type( ).
    WHEN zif_ref_data~dc_type_seahlp.
      get_ref_search_help( ).
  ENDCASE.

  IF d_only_customer_obj = abap_true.
    DELETE it_list_refs WHERE object_ref NP &apos;Z*&apos; AND object_ref NP &apos;Y*&apos;.
  ENDIF.

* Elimino duplicados
  SORT it_list_refs BY type_ref object_ref fullname_ref.
  DELETE ADJACENT DUPLICATES FROM it_list_refs
         COMPARING type_ref object_ref fullname_ref.

* Elimino aquellos objetos cuyo referencia sea la misma que la buscada. Por ejemplo:
* la tabla de la verificacion de una tabla es la misma que la tabla a buscar, esto se usa
* para tablas de textos.
  DELETE it_list_refs WHERE type_ref = d_type
                            AND object_ref = d_object.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_DOMAIN" VERSION="1" LANGU="S" DESCRIPT="Get reference of domains" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_domain.

  DATA ls_dd01v TYPE dd01v.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA ld_tipo TYPE ddtypes-typename.

  CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
    EXPORTING
      name          = d_object
    IMPORTING
      dd01v_wa      = ls_dd01v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.

* Valores base
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.

* Tabla de verificacion
    IF ls_dd01v-entitytab IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd01v-entitytab.
      ls_list_refs-type_ref = zif_ref_data~dc_type_table.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_ROLLNAME" VERSION="1" LANGU="S" DESCRIPT="Get refs of rollname" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130529" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_rollname.

  DATA ls_dd04v TYPE dd04v.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA ld_tipo TYPE ddtypes-typename.

  CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
    EXPORTING
      name          = d_object
    IMPORTING
      dd04v_wa      = ls_dd04v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.


  IF sy-subrc = 0.

* Valores base
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.

* Dominio
    IF ls_dd04v-domname IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd04v-domname.
      ls_list_refs-type_ref = zif_ref_data~dc_type_domain.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

* Ayuda para búsqueda
    IF ls_dd04v-shlpname IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd04v-shlpname.
      ls_list_refs-type_ref = zif_ref_data~dc_type_seahlp.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_SEARCH_HELP" VERSION="1" LANGU="S" DESCRIPT="Get references of search help" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_search_help.
  FIELD-SYMBOLS &lt;ls_dd31v&gt; TYPE dd31v.
  DATA ls_dd30v TYPE dd30v.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA lt_dd31v TYPE STANDARD TABLE OF dd31v.
  DATA ld_tipo TYPE ddtypes-typename.

  CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
    EXPORTING
      name          = d_object
    IMPORTING
      dd30v_wa      = ls_dd30v
    TABLES
      dd31v_tab     = lt_dd31v[]
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.

* Valores base
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.

* Método de obtencion de datos
* Como puede ser varios tipos de obtencion de datos uso una funcion para que me diga los tipos.
    IF ls_dd30v-selmethod IS NOT INITIAL.
      ld_tipo = ls_list_refs-object_ref = ls_dd30v-selmethod.
      CALL FUNCTION &apos;INTERN_TYPE_KIND&apos;
        EXPORTING
          typename = ld_tipo
        IMPORTING
          typekind = ls_list_refs-type_ref.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

* Tabla de textos
    IF ls_dd30v-texttab IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd30v-texttab.
      ls_list_refs-type_ref = zif_ref_data~dc_type_table.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.


* Exit de la ayuda para busqueda
    IF ls_dd30v-selmexit IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd30v-selmexit.
      ls_list_refs-type_ref = zif_ref_data~dc_type_function.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.


* Ayudas para busquedas incluidas.
    LOOP AT lt_dd31v ASSIGNING &lt;ls_dd31v&gt;.
      ls_list_refs-object_ref = &lt;ls_dd31v&gt;-subshlp.
      ls_list_refs-type_ref = zif_ref_data~dc_type_seahlp.
      APPEND ls_list_refs TO it_list_refs.

    ENDLOOP.
  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_TABLE" VERSION="1" LANGU="S" DESCRIPT="Get references of table" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20130529" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_table.
  FIELD-SYMBOLS &lt;ls_dd03p&gt; TYPE dd03p.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA lt_dd03p TYPE STANDARD TABLE OF dd03p.
  DATA ld_tipo TYPE ddtypes-typename.

  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = d_object
    TABLES
      dd03p_tab     = lt_dd03p
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.
* Los includes y append se eliminan porque los campos ya vienen en la tabla
    DELETE lt_dd03p WHERE fieldname = &apos;.INCLUDE&apos;.
    DELETE lt_dd03p WHERE fieldname = &apos;APPEND&apos;.

    LOOP AT lt_dd03p ASSIGNING &lt;ls_dd03p&gt;.

* Valores base
      ls_list_refs-level = d_level.
      ls_list_refs-type = d_type.
      ls_list_refs-object = d_object.

* Elemento de datos/estructura/tipo de tabla
      IF &lt;ls_dd03p&gt;-rollname IS NOT INITIAL
         AND &lt;ls_dd03p&gt;-comptype IS NOT INITIAL. &quot; No sea tipo instalado.
        CASE &lt;ls_dd03p&gt;-comptype.
          WHEN &apos;E&apos;. &quot; Elemento de datos
            ls_list_refs-type_ref = zif_ref_data~dc_type_dataelem.
            ls_list_refs-object_ref = &lt;ls_dd03p&gt;-rollname.
          WHEN &apos;L&apos;. &quot; Tipo tabla
            ls_list_refs-type_ref = zif_ref_data~dc_type_tabltype.
            ls_list_refs-object_ref = &lt;ls_dd03p&gt;-rollname.
          WHEN &apos;R&apos;. &quot; Clase o interface
            ls_list_refs-object_ref = &lt;ls_dd03p&gt;-rollname.
            ld_tipo = ls_list_refs-object_ref.
            CALL FUNCTION &apos;INTERN_TYPE_KIND&apos;
              EXPORTING
                typename = ld_tipo
              IMPORTING
                typekind = ls_list_refs-type_ref.
        ENDCASE.
        IF ls_list_refs-object_ref IS NOT INITIAL.
          APPEND ls_list_refs TO it_list_refs.
        ENDIF.
      ENDIF.

* Tabla de verificacion
      IF &lt;ls_dd03p&gt;-checktable IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd03p&gt;-checktable.
        ls_list_refs-type_ref = zif_ref_data~dc_type_table.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Tabla de dominio
      IF &lt;ls_dd03p&gt;-domname IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd03p&gt;-domname.
        ls_list_refs-type_ref = zif_ref_data~dc_type_domain.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Tabla de valores
      IF &lt;ls_dd03p&gt;-entitytab IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd03p&gt;-entitytab.
        ls_list_refs-type_ref = zif_ref_data~dc_type_table.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Tabla de referencia
      IF &lt;ls_dd03p&gt;-reftable IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd03p&gt;-reftable.
        ls_list_refs-type_ref = zif_ref_data~dc_type_table.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Ayuda de búsqueda
      IF &lt;ls_dd03p&gt;-shlpname IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd03p&gt;-shlpname.
        ls_list_refs-type_ref = zif_ref_data~dc_type_seahlp.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

    ENDLOOP.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_TABLE_TYPE" VERSION="1" LANGU="S" DESCRIPT="Get references of table type" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130529" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_table_type.
  DATA ls_dd40v TYPE dd40v.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA ld_tipo TYPE ddtypes-typename.

  CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
    EXPORTING
      name          = d_object
    IMPORTING
      dd40v_wa      = ls_dd40v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.

* Valores base
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.

* Tipo de datos principal
    IF ls_dd40v-rowtype IS NOT INITIAL.
      ld_tipo = ls_list_refs-object_ref = ls_dd40v-rowtype.
      CALL FUNCTION &apos;INTERN_TYPE_KIND&apos;
        EXPORTING
          typename = ld_tipo
        IMPORTING
          typekind = ls_list_refs-type_ref.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

* Elemento de datos en caso de que el tipo de tabla sea un ranges
    IF ls_dd40v-range_ctyp IS NOT INITIAL.
      ls_list_refs-object_ref = ls_dd40v-range_ctyp.
      ls_list_refs-type_ref = zif_ref_data~dc_type_dataelem.
      APPEND ls_list_refs TO it_list_refs.
    ENDIF.

  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="GET_REF_VIEW" VERSION="1" LANGU="S" DESCRIPT="Get references of view" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130528" CHANGEDBY="RODIVA01" CHANGEDON="20130529" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_ref_view.
  FIELD-SYMBOLS &lt;ls_dd26v&gt; TYPE dd26v.
  FIELD-SYMBOLS &lt;ls_dd27p&gt; TYPE dd27p.
  DATA lt_dd26v TYPE STANDARD TABLE OF dd26v.
  DATA lt_dd27p TYPE STANDARD TABLE OF dd27p.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.

  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name          = d_object
    TABLES
      dd26v_tab     = lt_dd26v[]
      dd27p_tab     = lt_dd27p[]
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.

* Valores base
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.

* Leo las tablas que componen la vista
    LOOP AT lt_dd26v ASSIGNING &lt;ls_dd26v&gt;.
      ls_list_refs-object_ref = &lt;ls_dd26v&gt;-tabname.
      ls_list_refs-type_ref = zif_ref_data~dc_type_table.
      APPEND ls_list_refs TO it_list_refs.
    ENDLOOP.

* Los campos de las vistas. Si se utiliza dentro de la recursividad, de la tabla
* que se encuentra en la tabla interna se determinan los campos que se añadirán.
* Pero como las referencias no tienen que ser siempre recursivas opto por añadir
* los campos.
    LOOP AT lt_dd27p ASSIGNING &lt;ls_dd27p&gt;.

* Elemento de datos
      IF &lt;ls_dd27p&gt;-rollname IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd27p&gt;-rollname.
        ls_list_refs-type_ref = zif_ref_data~dc_type_dataelem.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Dominio
      IF &lt;ls_dd27p&gt;-domname IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd27p&gt;-domname.
        ls_list_refs-type_ref = zif_ref_data~dc_type_domain.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Tabla de verificacion
      IF &lt;ls_dd27p&gt;-checktable IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd27p&gt;-checktable.
        ls_list_refs-type_ref = zif_ref_data~dc_type_table.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

* Ayuda para búsqueda
      IF &lt;ls_dd27p&gt;-shlpname IS NOT INITIAL.
        ls_list_refs-object_ref = &lt;ls_dd27p&gt;-shlpname.
        ls_list_refs-type_ref = zif_ref_data~dc_type_seahlp.
        APPEND ls_list_refs TO it_list_refs.
      ENDIF.

    ENDLOOP.

  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_DDIC" CMPNAME="SEARCH_REFS" VERSION="1" LANGU="S" DESCRIPT="Search reference" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_DDIC" CMPNAME="SEARCH_REFS" SCONAME="E_REFS" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS"/>
   <source>METHOD SEARCH_REFS.

  CLEAR e_refs.

* Primero obtengo las referencias del objeto pasado
  get_all_refs( ).

* Se devuelven los registros encontrados.
  e_refs = it_list_refs.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_REF_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Get down references of object" UUID="E2C96B3734E323F191180050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_REF_OBJECT" REFCLSNAME="ZIF_REF_DATA" VERSION="1" EXPOSURE="2" STATE="1" AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" RELTYPE="1"/>
  <publicSection>class ZCL_REF_OBJECT definition
  public
  create public .

*&quot;* public components of class ZCL_REF_OBJECT
*&quot;* do not include other source files here!!!
public section.

  interfaces ZIF_REF_DATA .

  methods SEARCH_REFS
    importing
      !I_OBJECT type ANY
      !I_TYPE type TROBJTYPE
      !I_LEVEL_DEPTH_MAX type I default 1
      !I_ONLY_CUSTOMER_OBJ type SAP_BOOL default &apos;X&apos;
    exporting
      !E_REFS type ZIF_REF_DATA~TY_T_LIST_REFS
    exceptions
      TYPE_OBJECT_NOT_VALID .</publicSection>
  <protectedSection>*&quot;* protected components of class ZCL_REF_OBJECT
*&quot;* do not include other source files here!!!
protected section.

  data D_LEVEL type SYTABIX .
  data IT_REFS type ZIF_REF_DATA~TY_T_LIST_REFS .
  data D_ONLY_CUSTOMER_OBJ type SAP_BOOL .

  methods GET_REFS_CHILD
    importing
      !I_REFS type ZIF_REF_DATA~TY_LIST_REFS
      !I_LEVEL_DEPTH_MAX type I .
  methods GET_ALL_REFS
    importing
      !I_OBJECT type ANY
      !I_TYPE type TROBJTYPE
    exporting
      !E_REFS type ZIF_REF_DATA~TY_T_LIST_REFS
    exceptions
      TYPE_OBJECT_NOT_VALID .</protectedSection>
  <privateSection>*&quot;* private components of class ZCL_REF_OBJECT
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_REF_OBJECT" CMPNAME="D_LEVEL" VERSION="1" LANGU="4" DESCRIPT="Level of search" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SYTABIX" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_OBJECT" CMPNAME="D_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="4" DESCRIPT="Only customer objects" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_OBJECT" CMPNAME="IT_REFS" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_ALL_REFS" VERSION="1" LANGU="4" DESCRIPT="Get all refereces" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDBY="RODIVA01" CHANGEDON="20130602" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_ALL_REFS" SCONAME="I_OBJECT" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_ALL_REFS" SCONAME="I_TYPE" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_ALL_REFS" SCONAME="E_REFS" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS"/>
   <exception CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_ALL_REFS" SCONAME="TYPE_OBJECT_NOT_VALID" VERSION="1" LANGU="4" DESCRIPT="The type of object is not valid" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000"/>
   <source>METHOD get_all_refs.
  DATA lo_source TYPE REF TO zcl_ref_source.
  DATA lo_ddic TYPE REF TO zcl_ref_ddic.


  CLEAR e_refs.

* Las referencias se separan en codigo fuente y diccionario.
  CASE i_type.
    WHEN zif_ref_data~dc_type_program
         OR zif_ref_data~dc_type_class
         OR zif_ref_data~dc_type_interface
         OR zif_ref_data~dc_type_function
         OR zif_ref_data~dc_type_webdynpro.

      CREATE OBJECT lo_source
        EXPORTING
          i_object              = i_object
          i_type                = i_type
          i_level               = d_level
          i_only_customer_obj   = d_only_customer_obj
        EXCEPTIONS
          error_object          = 1
          type_object_not_valid = 2
          OTHERS                = 3.
      IF sy-subrc = 0.

        CALL METHOD lo_source-&gt;search_refs
          EXPORTING
            i_local = abap_true
          IMPORTING
            e_refs  = e_refs.

        FREE lo_source.

      ENDIF.

    WHEN zif_ref_data~dc_type_table
         OR zif_ref_data~dc_type_struc
         OR zif_ref_data~dc_type_dataelem
         OR zif_ref_data~dc_type_domain
         OR zif_ref_data~dc_type_tabltype
         OR zif_ref_data~dc_type_seahlp
         OR zif_ref_data~dc_type_view.


      CREATE OBJECT lo_ddic
        EXPORTING
          i_object              = i_object
          i_type                = i_type
          i_level               = d_level
          i_only_customer_obj   = d_only_customer_obj
        EXCEPTIONS
          error_object          = 1
          type_object_not_valid = 2
          OTHERS                = 3.
      IF sy-subrc = 0.

        CALL METHOD lo_ddic-&gt;search_refs
          IMPORTING
            e_refs = e_refs.

        FREE lo_ddic.

      ENDIF.
    WHEN OTHERS.
      RAISE type_object_not_valid.
  ENDCASE.




ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_REFS_CHILD" VERSION="1" LANGU="4" DESCRIPT="Get references of child" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDBY="RODIVA01" CHANGEDON="20130602" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_REFS_CHILD" SCONAME="I_REFS" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="GET_REFS_CHILD" SCONAME="I_LEVEL_DEPTH_MAX" VERSION="1" LANGU="4" DESCRIPT="Level depth max" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>METHOD get_refs_child.
  FIELD-SYMBOLS &lt;ls_refs&gt; TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA lt_refs TYPE zif_ref_data~ty_t_list_refs.

* Si la referencia que pasan ya esta en la tabla no la vuelvo a buscar
  READ TABLE it_refs TRANSPORTING NO FIELDS WITH KEY object_ref = i_refs-object_ref
                                                     type_ref = i_refs-type_ref.
  IF sy-subrc NE 0.

* Añado el nivel del padre
    APPEND i_refs TO it_refs.

* Si el nivel actual es el mismo que el máximo entonces no se procesan los hijos.
    IF d_level &lt; i_level_depth_max.

* Incremento el nivel en un uno.
      ADD 1 TO d_level.

* Busco las referencias del objeto pasado
      CALL METHOD get_all_refs
        EXPORTING
          i_object              = i_refs-object_ref
          i_type                = i_refs-type_ref
        IMPORTING
          e_refs                = lt_refs
        EXCEPTIONS
          type_object_not_valid = 1
          OTHERS                = 2.
      IF sy-subrc = 0.

* Con las referencias del primer nivel encuentro las
        LOOP AT lt_refs ASSIGNING &lt;ls_refs&gt;.
          CALL METHOD get_refs_child
            EXPORTING
              i_refs            = &lt;ls_refs&gt;
              i_level_depth_max = i_level_depth_max.
        ENDLOOP.

      ENDIF.

* Con los hijos obtenidos resto uno para volver al nivel del padre.
      SUBTRACT 1 FROM d_level.

    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" VERSION="1" LANGU="4" DESCRIPT="Search references" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDBY="RODIVA01" CHANGEDON="20130602" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="I_OBJECT" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="I_TYPE" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="I_LEVEL_DEPTH_MAX" VERSION="1" LANGU="4" DESCRIPT="Level depth max" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="1"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="I_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="4" DESCRIPT="Only customer objects" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SAP_BOOL" PARVALUE="&apos;X&apos;"/>
   <parameter CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="E_REFS" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDBY="RODIVA01" CHANGEDON="20130805" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS"/>
   <exception CLSNAME="ZCL_REF_OBJECT" CMPNAME="SEARCH_REFS" SCONAME="TYPE_OBJECT_NOT_VALID" VERSION="1" LANGU="4" DESCRIPT="The type of object is not valid" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000"/>
   <source>METHOD search_refs.
  FIELD-SYMBOLS &lt;ls_refs&gt; TYPE LINE OF zif_ref_data~ty_t_list_refs.
  DATA lt_refs TYPE zif_ref_data~ty_t_list_refs.

  CLEAR: it_refs.

  d_level = 1.

  d_only_customer_obj = i_only_customer_obj.

* Busco las referencias del objeto principal
  CALL METHOD get_all_refs
    EXPORTING
      i_object              = i_object
      i_type                = i_type
    IMPORTING
      e_refs                = lt_refs
    EXCEPTIONS
      type_object_not_valid = 1
      OTHERS                = 2.
  IF sy-subrc = 0.

* Con las referencias del primer nivel encuentro las de los hijos
    LOOP AT lt_refs ASSIGNING &lt;ls_refs&gt;.
      CALL METHOD get_refs_child
        EXPORTING
          i_refs            = &lt;ls_refs&gt;
          i_level_depth_max = i_level_depth_max.
    ENDLOOP.

  ELSE.
    RAISE type_object_not_valid.
  ENDIF.

  e_refs = it_refs.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_REF_SOURCE" VERSION="1" LANGU="S" DESCRIPT="References source ABAP (prog/class/etc)" UUID="E2C254AA92F403F191180050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130521" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_REF_SOURCE" CMPNAME="TY_LIST_REFS" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="TY_LIST_REFS" TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCL_REF_SOURCE" CMPNAME="TY_T_LIST_REFS" VERSION="1" LANGU="S" ALIAS="X" EXPOSURE="2" STATE="1" EDITORDER="0 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" TYPTYPE="0" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" REFCLSNAME="ZIF_REF_DATA" REFCMPNAME="TY_T_LIST_REFS" TYPESRC_LENG="0 "/>
  <implementing CLSNAME="ZCL_REF_SOURCE" REFCLSNAME="ZIF_REF_DATA" VERSION="1" EXPOSURE="2" STATE="1" AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" RELTYPE="1"/>
  <publicSection>class ZCL_REF_SOURCE definition
  public
  create public .

*&quot;* public components of class ZCL_REF_SOURCE
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .

  interfaces ZIF_REF_DATA .

  aliases TY_LIST_REFS
    for ZIF_REF_DATA~TY_LIST_REFS .
  aliases TY_T_LIST_REFS
    for ZIF_REF_DATA~TY_T_LIST_REFS .

  methods CONSTRUCTOR
    importing
      !I_OBJECT type ANY
      !I_TYPE type TROBJTYPE
      !I_LEVEL type I optional
      !I_ONLY_CUSTOMER_OBJ type SAP_BOOL default &apos;X&apos;
    exceptions
      ERROR_OBJECT
      TYPE_OBJECT_NOT_VALID .
  methods SEARCH_REFS
    importing
      !I_LOCAL type SYCHAR01 optional
    exporting
      !E_REFS type ZIF_REF_DATA~TY_T_LIST_REFS .
  class-methods GET_INTERNAL_NAME
    importing
      !I_OBJECT type ANY
      !I_TYPE type TROBJTYPE
    exporting
      value(E_INTERNAL_NAME) type ANY
    exceptions
      TYPE_OBJECT_NOT_VALID .</publicSection>
  <protectedSection>*&quot;* protected components of class ZCL_REF_SOURCE
*&quot;* do not include other source files here!!!
protected section.

  data D_OBJECT type PROGRAM .
  data GO_COMPILER type ref to CL_ABAP_COMPILER .
  data D_INTERNAL_NAME type PROGRAM .
  data D_TYPE type TROBJTYPE .
  data IT_SCAN_REFS type SCR_GLREFS .
  data IT_LIST_REFS type ZIF_REF_DATA~TY_T_LIST_REFS .
  data D_LEVEL type I .
  data D_ONLY_CUSTOMER_OBJ type SAP_BOOL .

  methods BUILD_TAG_REF
    importing
      !I_TAG type SCR_TAG
    returning
      value(R_TAG_TXT) type STRING .
  methods ADAPT_REFS_LIST .
  methods GET_ALL_REFS
    importing
      !I_LOCAL type SYCHAR01 default ABAP_TRUE .
  methods ADAPT_REF_TAG_FU
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_TY
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_MI
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_IC
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_PR
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_SIMPLE
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .
  methods ADAPT_REF_TAG_MN
    importing
      !I_REF type SCR_GLREF
    changing
      !C_LIST_REF type ZIF_REF_DATA~TY_LIST_REFS .</protectedSection>
  <privateSection>*&quot;* private components of class ZCL_REF_SOURCE
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_REF_SOURCE" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="D_INTERNAL_NAME" VERSION="1" LANGU="S" DESCRIPT="Program/transaction in SQL trace analysis" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="D_LEVEL" VERSION="1" LANGU="S" DESCRIPT="Level for recursive references" EXPOSURE="1" STATE="1" EDITORDER="7 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="D_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Program/transaction in SQL trace analysis" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="D_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="S" DESCRIPT="only customer objects" EXPOSURE="1" STATE="1" EDITORDER="8 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="D_TYPE" VERSION="1" LANGU="S" DESCRIPT="Tipo de objeto" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="GO_COMPILER" VERSION="1" LANGU="S" DESCRIPT="Cross Reference of an ABAP Program" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_COMPILER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="IT_LIST_REFS" VERSION="1" LANGU="S" DESCRIPT="List of references" EXPOSURE="1" STATE="1" EDITORDER="6 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_REF_SOURCE" CMPNAME="IT_SCAN_REFS" VERSION="1" LANGU="S" DESCRIPT="Tabla de referencias" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SCR_GLREFS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REFS_LIST" VERSION="1" LANGU="S" DESCRIPT="Adapt references to list" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD adapt_refs_list.
  FIELD-SYMBOLS &lt;ls_scan_refs&gt; LIKE LINE OF it_scan_refs.
  DATA ls_list_refs TYPE LINE OF zif_ref_data~ty_t_list_refs.

  LOOP AT it_scan_refs ASSIGNING &lt;ls_scan_refs&gt;.
    CLEAR ls_list_refs.
    ls_list_refs-level = d_level.
    ls_list_refs-type = d_type.
    ls_list_refs-object = d_object.
    ls_list_refs-internal_name = d_internal_name.
    ls_list_refs-fullname_ref = &lt;ls_scan_refs&gt;-full_name.

    CASE &lt;ls_scan_refs&gt;-tag.
      WHEN &apos;PR&apos;. &quot; Program
        adapt_ref_tag_pr( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                          CHANGING c_list_ref = ls_list_refs ).
      WHEN &apos;FU&apos;. &quot; Function module.
        adapt_ref_tag_fu( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                          CHANGING c_list_ref = ls_list_refs ).
      WHEN &apos;MI&apos;. &quot; Message class
        adapt_ref_tag_mi( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                          CHANGING c_list_ref = ls_list_refs ).
      WHEN &apos;TY&apos;. &quot; Data type
        adapt_ref_tag_ty( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                        CHANGING c_list_ref = ls_list_refs ).
      WHEN &apos;IC&apos;. &quot; Include
        adapt_ref_tag_ic( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                        CHANGING c_list_ref = ls_list_refs ).
      WHEN &apos;MN&apos;. &quot; Individual messages
        adapt_ref_tag_mn( EXPORTING i_ref = &lt;ls_scan_refs&gt;
                      CHANGING c_list_ref = ls_list_refs ).
    ENDCASE.

* Si algunos de los campos tipo de referencia o nombre de la referencia
* están en blanco no lo añado porque, o bien, no se ha determinado bien a pesar
* de ser un tag correcto, o bien, el tag no se va a procesar.
    IF ls_list_refs-type_ref IS NOT INITIAL AND ls_list_refs-object_ref IS NOT INITIAL.

* Recupero el nombre interno del objeto referencia. Útil cuando se va a explotar
* dicho objeto para otras cosas: como traducciones.
      CALL METHOD get_internal_name
        EXPORTING
          i_object              = ls_list_refs-object_ref
          i_type                = ls_list_refs-type_ref
        IMPORTING
          e_internal_name       = ls_list_refs-internal_name_ref
        EXCEPTIONS
          type_object_not_valid = 1
          OTHERS                = 2.
      IF sy-subrc &lt;&gt; 0.
        ls_list_refs-internal_name_ref = ls_list_refs-object_ref.
      ENDIF.

* Si el objeto ya esta insertado no lo vuelvo hacer.
* A veces se devuelven referencias duplicadas debido a subobjetos. Ejemplo la clase de mensajes.
* Por cada mensaje que hay en el objeto, se repite la clase de mensajes.
      READ TABLE it_list_refs TRANSPORTING NO FIELDS WITH KEY type_ref = ls_list_refs-type_ref
                                                              object_ref = ls_list_refs-object_ref.
      IF sy-subrc NE 0.
        IF d_only_customer_obj = abap_true AND ( ls_list_refs-object_ref CP &apos;Z*&apos; OR ls_list_refs-object_ref CP &apos;Y*&apos; ).
          APPEND ls_list_refs TO it_list_refs.
        ELSEIF d_only_customer_obj = abap_false.
          APPEND ls_list_refs TO it_list_refs.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDLOOP.

* Para evitar bucles infitos, borro los objetos cuya referencia sea la misma que la que se busca:
  DELETE it_list_refs WHERE type_ref = d_type
                            AND object_ref = d_object.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_FU" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag FU (Function module)" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_FU" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_FU" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_fu.

* El tag de las funciones requiere una adaptación simple. Por ello al método generico
* para eso.
  CALL METHOD adapt_ref_tag_simple
    EXPORTING
      i_ref      = i_ref
    CHANGING
      c_list_ref = c_list_ref.

* Tipo de objeto de referecia
  c_list_ref-type_ref = zif_ref_data~dc_type_function.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_IC" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag IC (Include)" EXPOSURE="1" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_IC" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_IC" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_ic.
  DATA ld_full_name TYPE string.
  DATA ld_tag TYPE string.

* Los includes que contienen &quot;=&quot; se ignoran, el motivo es que son los includes internos
* de la clases. Que sirven para separar las secciones públicas, privadas, etc..
  IF i_ref-full_name NS &apos;=&apos;.
* Obtengo el tag para buscar en el full name.
    ld_tag = build_tag_ref( i_ref-tag ).

* Paso el nombre completo al campo de referencia.
    c_list_ref-object_ref = i_ref-full_name.

* Elimino el tag del objeto para quede limpio.
    REPLACE ld_tag IN c_list_ref-object_ref WITH space.
    CONDENSE c_list_ref-object_ref.

* Tipo de objeto de referecia. Include y programa son lo mismo.
    c_list_ref-type_ref = zif_ref_data~dc_type_program.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MI" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag MI (Message class)" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MI" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MI" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_mi.

* El tag de los programa requiere una adaptación simple. Por ello al método generico
* para eso.
  CALL METHOD adapt_ref_tag_simple
    EXPORTING
      i_ref      = i_ref
    CHANGING
      c_list_ref = c_list_ref.

* Tipo de objeto de referecia
  c_list_ref-type_ref = zif_ref_data~dc_type_messclas.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MN" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag IC (Include)" EXPOSURE="1" STATE="1" EDITORDER="10 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140219" CHANGEDBY="RODIVA01" CHANGEDON="20140219" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MN" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140219" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_MN" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="Datos generales material" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140219" CHANGEDON="00000000" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_mn.

  c_list_ref-object_ref = i_ref-full_name.

* Quito los tags de separacion entre clase de mensaje y número mensaje
  REPLACE &apos;\MI:&apos; IN c_list_ref-object_ref WITH space.
  REPLACE &apos;\MN:&apos; IN c_list_ref-object_ref WITH space.

* Tipo de objeto de referecia
  c_list_ref-type_ref = zif_ref_data~dc_type_single_mess.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_PR" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag PR (Program)" EXPOSURE="1" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_PR" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_PR" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_pr.

* El tag de los programa requiere una adaptación simple. Por ello al método generico
* para eso.
  CALL METHOD adapt_ref_tag_simple
    EXPORTING
      i_ref      = i_ref
    CHANGING
      c_list_ref = c_list_ref.

* Tipo de objeto de referecia
  c_list_ref-type_ref = zif_ref_data~dc_type_program.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_SIMPLE" VERSION="1" LANGU="S" DESCRIPT="Adapt reference of simple tag (FU/PR/etc)" EXPOSURE="1" STATE="1" EDITORDER="9 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_SIMPLE" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_SIMPLE" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD ADAPT_REF_TAG_SIMPLE.

  DATA ld_full_name TYPE string.
  DATA ld_tag TYPE string.

* El programa hay que mirar que no sea el propio que estamos buscando las
* refs. Si es el mismo no se trata.
  IF i_ref-full_name NS d_object.

* Obtengo el tag para buscar en el full name.
    ld_tag = build_tag_ref( i_ref-tag ).

* Paso el nombre completo al campo de referencia.
    c_list_ref-object_ref = i_ref-full_name.

* Elimino el tag del objeto para quede limpio.
    REPLACE ld_tag IN c_list_ref-object_ref WITH space.
    CONDENSE c_list_ref-object_ref.


  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_TY" VERSION="1" LANGU="S" DESCRIPT="Adapt reference tag TY (Data type)" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130522" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_TY" SCONAME="I_REF" VERSION="1" LANGU="S" DESCRIPT="Ref.cruzada: Lista completa de todos puntos utilización" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130522" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_GLREF"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="ADAPT_REF_TAG_TY" SCONAME="C_LIST_REF" VERSION="1" LANGU="S" DESCRIPT="List of references" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130522" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_LIST_REFS"/>
   <source>METHOD adapt_ref_tag_ty.
  DATA ld_tag TYPE string.
  DATA ld_cont TYPE i.
  DATA ld_symbol TYPE REF TO cl_abap_comp_type.
  DATA ld_tipo TYPE ddtypes-typename.

* Genero el tag para buscar dentro del nombre del objeto.
  ld_tag = build_tag_ref( i_ref-tag ).

* Busco el número de veces que se repite el tag. Solo interesa aquellos que tienen una vez el tag.
* Si hay más significa que esta el campo seguido del objeto que usa.
* Ejemplo: en el caso de tener MARA-MATNR. El primero tag es la MARA y el segundo tag es del campo.
* Pero justo antes abra un solo con la tabla MARA.
  FIND ALL OCCURRENCES OF REGEX &apos;\\*:&apos; IN i_ref-full_name MATCH COUNT ld_cont.
  IF ld_cont = 1.

* Aprovecho la adaptación simple del tag para saber el nombre del objeto.
    CALL METHOD adapt_ref_tag_simple
      EXPORTING
        i_ref      = i_ref
      CHANGING
        c_list_ref = c_list_ref.

* Para saber el tipo de objeto hay que consultar la clase con los atributos del tipo de campos.
    IF i_ref-symbol IS NOT INITIAL.
      TRY.
          ld_symbol ?= i_ref-symbol.
          CASE ld_symbol-&gt;type_kind.
            WHEN cl_abap_comp_type=&gt;type_kind_interface.
              c_list_ref-type_ref = zif_ref_data~dc_type_interface. &quot; Interface
* Para objetos elementos como para clases uso una función de SAP para saber el tipo exacto.
* Ya que si es diccionario el tipo de datos es el mismo para elemento de datos y estructuras.
* Para clases el tipo es el mismo para clases que interfaces.
* Para estructuras y tipos de tabla el tipo informado es el exacto, aún asi lanzo la función para asegurarme.
            WHEN cl_abap_comp_type=&gt;type_kind_elementary
                OR cl_abap_comp_type=&gt;type_kind_class
                OR cl_abap_comp_type=&gt;type_kind_structure
                OR cl_abap_comp_type=&gt;type_kind_table
                OR cl_abap_comp_type=&gt;type_kind_reference.
* Llamo a una función de SAP que determina que tipo de diccionario es
              ld_tipo = c_list_ref-object_ref.
              CALL FUNCTION &apos;INTERN_TYPE_KIND&apos;
                EXPORTING
                  typename = ld_tipo
                IMPORTING
                  typekind = c_list_ref-type_ref.
          ENDCASE.
        CATCH cx_root.
* Se produce una excepción cuando symbolo del objeto es de un método. Aunque por el fullname sea de una clase.
* Se ignora porque esa misma clase se captura por otro tipo de &quot;symbol&quot;.
      ENDTRY.
    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="BUILD_TAG_REF" VERSION="1" LANGU="S" DESCRIPT="Build tag for search full_name" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="BUILD_TAG_REF" SCONAME="I_TAG" VERSION="1" LANGU="S" DESCRIPT="Identificación p.clases de objeto" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SCR_TAG"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="BUILD_TAG_REF" SCONAME="R_TAG_TXT" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>METHOD BUILD_TAG_REF.
  CLEAR r_tag_txt.

  CONCATENATE &apos;\&apos; i_tag &apos;:&apos; INTO r_tag_txt.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="S" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="I_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Program/transaction in SQL trace analysis" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="I_TYPE" VERSION="1" LANGU="S" DESCRIPT="Tipo de objeto" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="I_LEVEL" VERSION="1" LANGU="S" DESCRIPT="Level for recursive references" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="I_ONLY_CUSTOMER_OBJ" VERSION="1" LANGU="S" DESCRIPT="Only customer objects" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130805" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SAP_BOOL" PARVALUE="&apos;X&apos;"/>
   <exception CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="ERROR_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Error in the object" MTDTYPE="2" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDON="00000000"/>
   <exception CLSNAME="ZCL_REF_SOURCE" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_OBJECT_NOT_VALID" VERSION="1" LANGU="S" DESCRIPT="The type of object is not valid" MTDTYPE="2" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000"/>
   <source>METHOD constructor.

  d_object = i_object.
  d_type = i_type.

* El parametro I_LEVEL sirve para llamadas recursivas para encontrar referencias
* del objeto. Este nivel se guardara en la tabla de referencias con formato listado.
  IF i_level IS SUPPLIED.
    d_level = i_level.
  ELSE.
    d_level = 1.
  ENDIF.

* Parametro para leer solo los objetos de clientes
  d_only_customer_obj = i_only_customer_obj.

* Obtengo el nombre interno para poderlo pasar a la clase del compilador. Para programas no es necesario,
* pero para clases si.
* Instancio la clase del compilador pasandole el nombre del objeto
  CALL METHOD get_internal_name
    EXPORTING
      i_object              = d_object
      i_type                = d_type
    IMPORTING
      e_internal_name       = d_internal_name
    EXCEPTIONS
      type_object_not_valid = 1
      OTHERS                = 2.

  IF sy-subrc &lt;&gt; 0.
    RAISE type_object_not_valid.
  ENDIF.


  CREATE OBJECT go_compiler
    EXPORTING
      p_name             = d_internal_name
    EXCEPTIONS
      program_name_empty = 1
      OTHERS             = 2.
  IF sy-subrc NE 0.
    RAISE error_object.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_ALL_REFS" VERSION="1" LANGU="S" DESCRIPT="Get all refs of object" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_ALL_REFS" SCONAME="I_LOCAL" VERSION="1" LANGU="S" DESCRIPT="Local data" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20130526" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYCHAR01" PARVALUE="ABAP_TRUE" PAROPTIONL="X"/>
   <source>METHOD GET_ALL_REFS.

  CALL METHOD go_compiler-&gt;get_all_refs
    EXPORTING
      p_local  = i_local
    IMPORTING
      p_result = it_scan_refs.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_INTERNAL_NAME" VERSION="1" LANGU="S" DESCRIPT="Get internal name of object" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130521" CHANGEDBY="RODIVA01" CHANGEDON="20140216" MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_INTERNAL_NAME" SCONAME="I_OBJECT" VERSION="1" LANGU="S" DESCRIPT="Object name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140216" CHANGEDBY="RODIVA01" CHANGEDON="20140216" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_INTERNAL_NAME" SCONAME="I_TYPE" VERSION="1" LANGU="S" DESCRIPT="Tipo de objeto" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140216" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_INTERNAL_NAME" SCONAME="E_INTERNAL_NAME" VERSION="1" LANGU="S" DESCRIPT="Internal name" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140216" CHANGEDBY="RODIVA01" CHANGEDON="20140216" PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_REF_SOURCE" CMPNAME="GET_INTERNAL_NAME" SCONAME="TYPE_OBJECT_NOT_VALID" VERSION="1" LANGU="S" DESCRIPT="Type is not valid" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130530" CHANGEDON="00000000"/>
   <source>METHOD get_internal_name.
  DATA ld_class TYPE seoclsname.
  DATA ld_wda TYPE wdy_md_object_name.
  DATA ld_progname TYPE program.
  CASE I_type.
    WHEN zif_ref_data~dc_type_program. &quot; Program
* Para el caso de un programa no hay cambos.
      e_internal_name = i_object.
    WHEN zif_ref_data~dc_type_class. &quot; Clase
      ld_class = i_object.
      e_internal_name = cl_oo_classname_service=&gt;get_classpool_name( ld_class ).
    WHEN zif_ref_data~dc_type_interface. &quot; Interface
      ld_class = i_object.
      e_internal_name = cl_oo_classname_service=&gt;get_interfacepool_name( ld_class ).
    WHEN zif_ref_data~dc_type_function. &quot; Function
* Para obtener las referencias de una función hay que navegar al grupo de funciones.
      SELECT SINGLE pname INTO e_internal_name
             FROM tfdir WHERE funcname = i_object.
    WHEN zif_ref_data~dc_type_webdynpro. &quot; Webdynpro componente
      ld_wda = i_object.
      CALL FUNCTION &apos;WDY_WB_GET_CLSNAME_WITH_GENERA&apos;
        EXPORTING
          p_component      = ld_wda
        IMPORTING
          p_progname       = ld_progname
        EXCEPTIONS
          not_existing     = 1
          is_interface     = 2
          generation_error = 3
          OTHERS           = 4.
      IF sy-subrc = 0.
        e_internal_name = ld_progname.
      ENDIF.
    WHEN OTHERS.
      RAISE type_object_not_valid.
  ENDCASE.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_REF_SOURCE" CMPNAME="SEARCH_REFS" VERSION="1" LANGU="S" DESCRIPT="Search reference" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="SEARCH_REFS" SCONAME="I_LOCAL" VERSION="1" LANGU="S" DESCRIPT="Local object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYCHAR01" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_REF_SOURCE" CMPNAME="SEARCH_REFS" SCONAME="E_REFS" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20130602" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_REF_DATA~TY_T_LIST_REFS"/>
   <source>METHOD SEARCH_REFS.

  CLEAR e_refs.

* Primero obtengo las referencias del objeto pasado
  get_all_refs( i_local ).

* Segundo convierto la tabla de datos en informacion legible, a formato listado.
  adapt_refs_list( ).

* Se devuelven los registros encontrados.
  e_refs = it_list_refs.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_CMP" VERSION="1" LANGU="E" DESCRIPT="Components" UUID="E3A16051D53426F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZTRANS_CMP" CMPNAME="TY_PARAMS_COMP" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="29 " R3RELEASE="700" TYPESRC_LENG="129 " TYPESRC='begin of ty_params_comp,
          depth_refs type i, &quot;Nivel de búsqueda de objetos a traducir
         end of ty_params_comp
'/>
  <types CLSNAME="ZTRANS_CMP" CMPNAME="TY_OBJECT_LIST" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="6 " SRCROW2="22 " SRCCOLUMN2="35 " TYPESRC_LENG="279 " TYPESRC="BEGIN OF ty_object_list,
                  pgmid	TYPE pgmid,
                  object TYPE trobjtype,
                  text TYPE ko100-text,
                  class TYPE seoclsname,
                  ref_class TYPE REF TO ztrans_cmp,
               END OF ty_object_list
"/>
  <types CLSNAME="ZTRANS_CMP" CMPNAME="TY_T_OBJECT_LIST" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" TYPTYPE="4" SRCROW1="24 " SRCCOLUMN1="6 " SRCROW2="24 " SRCCOLUMN2="59 " TYPESRC_LENG="56 " TYPESRC="ty_t_object_list TYPE STANDARD TABLE OF ty_object_list
"/>
  <types CLSNAME="ZTRANS_CMP" CMPNAME="TY_COMPONENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" TYPTYPE="4" SRCROW1="26 " SRCCOLUMN1="6 " SRCROW2="30 " SRCCOLUMN2="30 " TYPESRC_LENG="180 " TYPESRC="BEGIN OF ty_components,
              object TYPE trobjtype,
              obj_name TYPE sobj_name,
              obj_name_int TYPE sobj_name,
           END OF ty_components
"/>
  <types CLSNAME="ZTRANS_CMP" CMPNAME="TY_T_COMPONENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" TYPTYPE="4" SRCROW1="32 " SRCCOLUMN1="6 " SRCROW2="32 " SRCCOLUMN2="57 " TYPESRC_LENG="54 " TYPESRC="ty_t_components TYPE STANDARD TABLE OF ty_components
"/>
  <publicSection>*----------------------------------------------------------------------*
*       CLASS ZTRANS_CMP  DEFINITIO
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ztrans_cmp DEFINITION
  PUBLIC
  CREATE PUBLIC .

*&quot;* public components of class ZTRANS_CMP
*&quot;* do not include other source files here!!!
  PUBLIC SECTION.
    TYPE-POOLS abap .

    TYPES:
      BEGIN OF ty_object_list,
                  pgmid	TYPE pgmid,
                  object TYPE trobjtype,
                  text TYPE ko100-text,
                  class TYPE seoclsname,
                  ref_class TYPE REF TO ztrans_cmp,
               END OF ty_object_list .
    TYPES:
      ty_t_object_list TYPE STANDARD TABLE OF ty_object_list .
    TYPES:
      BEGIN OF ty_components,
              object TYPE trobjtype,
              obj_name TYPE sobj_name,
              obj_name_int TYPE sobj_name,
           END OF ty_components .
    TYPES:
      ty_t_components TYPE STANDARD TABLE OF ty_components .

    CLASS-METHODS get_objectlist
      EXPORTING
        !e_object_list TYPE ty_t_object_list .
    METHODS get_components
      EXPORTING
        !e_components TYPE ty_t_components .
    METHODS get_objects_type
      RETURNING
        value(r_objects) TYPE objtyptable .
    METHODS check_object_exists
      IMPORTING
        !i_pgmid TYPE pgmid
        !i_object TYPE trobjtype
        !i_obj_name TYPE sobj_name
      RETURNING
        value(r_exist) TYPE sap_bool .
    METHODS set_params
      IMPORTING
        !i_depth_refs TYPE i DEFAULT 2 .</publicSection>
  <protectedSection>*&quot;* protected components of class ZZC_CA02703
*&quot;* do not include other source files here!!!
PROTECTED SECTION.
  types: begin of ty_params_comp,
          depth_refs type i, &quot;Nivel de búsqueda de objetos a traducir
         end of ty_params_comp.
  DATA d_object TYPE trobjtype .
  DATA d_obj_name TYPE sobj_name .
  data et_params_comp type ty_params_comp.</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02703
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZTRANS_CMP" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZTRANS_CMP" CMPNAME="D_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_CMP" CMPNAME="D_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOBJ_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_CMP" CMPNAME="ET_PARAMS_COMP" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_PARAMS_COMP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" VERSION="1" LANGU="4" DESCRIPT="Check if the object exist" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" SCONAME="I_PGMID" VERSION="1" LANGU="4" DESCRIPT="Program ID in Requests and Tasks" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PGMID"/>
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" SCONAME="I_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" SCONAME="I_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOBJ_NAME"/>
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" SCONAME="R_EXIST" VERSION="1" LANGU="4" DESCRIPT="Boolean Variable (X=True, Space=False)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SAP_BOOL"/>
   <source>METHOD check_object_exists.
r_exist = abap_false.

* Como la mayoria de objetos (por no decir todos) que se traducen existen en la TADIR, la validacion
* se pone en la clase padre. Para casos concretos se hará sobrecarga.
  CLEAR: d_object, d_obj_name.

  SELECT SINGLE object obj_name INTO (d_object, d_obj_name)
         FROM tadir
         WHERE pgmid = i_pgmid
               AND object = i_object
               AND obj_name = i_obj_name.
  IF sy-subrc = 0.
    r_exist = abap_true.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="1" LANGU="4" DESCRIPT="Get components" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" SCONAME="E_COMPONENTS" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_COMPONENTS"/>
   <source>method GET_COMPONENTS.
endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTLIST" VERSION="1" LANGU="4" DESCRIPT="Get object list" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTLIST" SCONAME="E_OBJECT_LIST" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_OBJECT_LIST"/>
   <source>METHOD GET_OBJECTLIST.
  FIELD-SYMBOLS &lt;ls_classlist&gt; TYPE LINE OF seo_inheritances.
  FIELD-SYMBOLS &lt;ls_objects&gt; TYPE LINE OF objtyptable.
  FIELD-SYMBOLS &lt;ls_types_out&gt; TYPE ko100.
  DATA lt_classlist TYPE seo_inheritances.
  DATA ls_object_list TYPE LINE OF ty_t_object_list.
  DATA lt_objects TYPE objtyptable.
  DATA lt_types_in TYPE STANDARD TABLE OF ko105.
  DATA ls_types_in TYPE ko105.
  DATA lt_types_out TYPE STANDARD TABLE OF ko100.

  CLEAR e_object_list.

* Leo todas las clases que heredan de la clase principal de componentes.
  SELECT * FROM vseoextend INTO TABLE lt_classlist
    WHERE refclsname = &apos;ZTRANS_CMP&apos;
    AND version = &apos;1&apos;.

  IF sy-subrc = 0.
    LOOP AT lt_classlist ASSIGNING &lt;ls_classlist&gt;.
      CLEAR ls_object_list.

      ls_object_list-class = &lt;ls_classlist&gt;-clsname.
* Cualquier excepcion al instanciar la clase o al llamar de sus métodos hará que no se
* tenga en cuenta la clase.
      TRY.
* Instancio la clase que obtendrá los componentes
          CREATE OBJECT ls_object_list-ref_class TYPE (&lt;ls_classlist&gt;-clsname).

* Llamo al método para que me devuelva los objetos asociados al componente. Por ejemplo:
* para la clase para los componentes del diccionario devolverá: DTEL, DOMA, TABL, etc..
          lt_objects = ls_object_list-ref_class-&gt;get_objects_type( ).

          LOOP AT lt_objects ASSIGNING &lt;ls_objects&gt;.
            CLEAR: lt_types_in, lt_types_out, lt_types_in.
* Recupero la descripción del objeto para pasarla a la tabla principal. También servirá
* para validar que el objeto exista.
            ls_types_in-object = &lt;ls_objects&gt;.
            APPEND ls_types_in TO lt_types_in.
            CALL FUNCTION &apos;TRINT_OBJECT_TABLE&apos;
              TABLES
                tt_types_in  = lt_types_in
                tt_types_out = lt_types_out.

            READ TABLE lt_types_out ASSIGNING &lt;ls_types_out&gt; INDEX 1.
            IF sy-subrc = 0.
              MOVE-CORRESPONDING &lt;ls_types_out&gt; to ls_object_list.
              APPEND ls_object_list TO e_object_list.
            ENDIF..

          ENDLOOP.

          CLEAR lt_objects.

        CATCH cx_root.
      ENDTRY.

    ENDLOOP.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="1" LANGU="4" DESCRIPT="Get objects type" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" SCONAME="R_OBJECTS" VERSION="1" LANGU="4" DESCRIPT="Object Type Table" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="OBJTYPTABLE"/>
   <source>method GET_OBJECTS_TYPE.
endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="SET_PARAMS" VERSION="1" LANGU="4" DESCRIPT="Set params for search components" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_CMP" CMPNAME="SET_PARAMS" SCONAME="I_DEPTH_REFS" VERSION="1" LANGU="4" DESCRIPT="Depth level refs(PROG,CLAS,FUNC)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="2" PAROPTIONL="X"/>
   <source>METHOD SET_PARAMS.

* Nivel de búsqueda de objetos a traducir a partir del objeto principal.
  et_params_comp-depth_refs = i_depth_refs.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_CMP_DDIC" VERSION="1" LANGU="E" DESCRIPT="Components: Data Dictionary" UUID="E3A7B99527BB93F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="20140309" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_CMP" CHANGEDBY="RODIVA01">
  <publicSection>class ZTRANS_CMP_DDIC definition
  public
  inheriting from ZTRANS_CMP
  final
  create public .

*&quot;* public components of class ZTRANS_CMP_DDIC
*&quot;* do not include other source files here!!!
public section.

  methods GET_OBJECTS_TYPE
    redefinition .
  methods GET_COMPONENTS
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_CMP_DDIC
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_CMP_DDIC
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_CMP_DDIC" REFCLSNAME="ZTRANS_CMP" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309">
   <redefinition CLSNAME="ZTRANS_CMP_DDIC" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_COMPONENTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_DDIC" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_OBJECTS_TYPE"/>
  </inheritance>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_components.
  FIELD-SYMBOLS &lt;ls_refs&gt; TYPE LINE OF zif_ref_data=&gt;ty_t_list_refs.
  DATA lt_refs TYPE zif_ref_data=&gt;ty_t_list_refs.
  DATA lo_refs TYPE REF TO zcl_ref_object.
  DATA ls_components TYPE LINE OF ty_t_components.

  CLEAR e_components.

  CREATE OBJECT lo_refs.

  CALL METHOD lo_refs-&gt;search_refs
    EXPORTING
      i_object              = d_obj_name
      i_type                = d_object
      i_level_depth_max     = et_params_comp-depth_refs
    IMPORTING
      e_refs                = lt_refs
    EXCEPTIONS
      type_object_not_valid = 1
      OTHERS                = 2.

  IF sy-subrc = 0.

* Leo el primer registro de la tabla de ref
* Se pasa el componente pasado
    ls_components-object = d_object.
    ls_components-obj_name = d_obj_name.
    APPEND ls_components TO e_components.


* Se pasan las referencia del objeto a la tabla de componentes
* Uso la estructura base para añadir los campos comunes. Esto simplifica el codigo.
    LOOP AT lt_refs ASSIGNING &lt;ls_refs&gt;.
      ls_components-object = &lt;ls_refs&gt;-type_ref.
* Devuelvo el nombre interno porque para funciones y clases se ha de usar el interno para recuperar los extos.
      IF &lt;ls_refs&gt;-internal_name_ref IS NOT INITIAL.
        ls_components-obj_name = &lt;ls_refs&gt;-internal_name_ref.
      ELSE.
        ls_components-obj_name = &lt;ls_refs&gt;-object_ref.
      ENDIF.
      APPEND ls_components TO e_components.
    ENDLOOP.

    FREE lo_refs.

  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_objects_type.
* Tablas
  APPEND zif_ref_data=&gt;dc_type_table TO r_objects.
* Estructuras
  APPEND zif_ref_data=&gt;dc_type_struc TO r_objects.
* Elemento de datos
  APPEND zif_ref_data=&gt;dc_type_dataelem TO r_objects.
* Dominio
  APPEND zif_ref_data=&gt;dc_type_domain TO r_objects.
* Tipo tabla
  APPEND zif_ref_data=&gt;dc_type_tabltype TO r_objects.
* Ayuda para búsqued
  APPEND zif_ref_data=&gt;dc_type_seahlp TO r_objects.
* Vistas
  APPEND zif_ref_data=&gt;dc_type_view TO r_objects.


ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_CMP_FUNCTION" VERSION="1" LANGU="E" DESCRIPT="Components: Function/Function Group plugin" UUID="E3A2038266B0D8F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140302" CHANGEDBY="RODIVA01" CHANGEDON="20140302" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_CMP">
  <publicSection>class ZTRANS_CMP_FUNCTION definition
  public
  inheriting from ZTRANS_CMP
  final
  create public .

*&quot;* public components of class ZTRANS_CMP_FUNCTION
*&quot;* do not include other source files here!!!
public section.

  methods CHECK_OBJECT_EXISTS
    redefinition .
  methods GET_COMPONENTS
    redefinition .
  methods GET_OBJECTS_TYPE
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_CMP_FUNCTION
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_CMP_FUNCTION
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_CMP_FUNCTION" REFCLSNAME="ZTRANS_CMP" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140302" CHANGEDBY="RODIVA01" CHANGEDON="20140302">
   <redefinition CLSNAME="ZTRANS_CMP_FUNCTION" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="CHECK_OBJECT_EXISTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_FUNCTION" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_COMPONENTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_FUNCTION" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_OBJECTS_TYPE"/>
  </inheritance>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="CHECK_OBJECT_EXISTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD check_object_exists.
  r_exist = abap_false.

  CLEAR: d_object, d_obj_name.

* Las funciones/grupo de funciones el comprobar su existencia se hace distinto.
  IF i_object = &apos;FUNC&apos;.
* Si es una función se mira si esta asociado a un grupo de funciones
    SELECT SINGLE funcname INTO d_obj_name
               FROM tfdir WHERE funcname = i_obj_name.
    IF sy-subrc = 0.
      d_object = i_object.
      r_exist = abap_true.
    ENDIF.
  ELSEIF i_object = &apos;FUGR&apos;.
    SELECT SINGLE area INTO d_obj_name
           FROM tlibg
           WHERE area = i_obj_name.
    IF sy-subrc = 0.
      d_object = i_object.
      r_exist = abap_true.
    ENDIF.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_components.
  FIELD-SYMBOLS &lt;ls_refs&gt; TYPE LINE OF zif_ref_data=&gt;ty_t_list_refs.
  DATA lt_refs TYPE zif_ref_data=&gt;ty_t_list_refs.
  DATA lo_refs TYPE REF TO zcl_ref_object.
  DATA ls_components TYPE LINE OF ty_t_components.

  CLEAR e_components.

  CREATE OBJECT lo_refs.

  CALL METHOD lo_refs-&gt;search_refs
    EXPORTING
      i_object              = d_obj_name
      i_type                = d_object
      i_level_depth_max     = et_params_comp-depth_refs
    IMPORTING
      e_refs                = lt_refs
    EXCEPTIONS
      type_object_not_valid = 1
      OTHERS                = 2.

  IF sy-subrc = 0.

* Leo el primer registro de la tabla de ref
* Las funciones se convierten a grupos de funciones, debido a que los textos
* esta en el grupo de funciones.
    IF d_object = &apos;FUNC&apos;.
      ls_components-object = &apos;FUGR&apos;.
    ELSE.
      ls_components-object = d_object.
    ENDIF.

* Obtengo el nombre del grupo de funciones en caso de ser una función.
    CALL METHOD zcl_ref_source=&gt;get_internal_name
      EXPORTING
        i_object              = d_obj_name
        i_type                = d_object
      IMPORTING
        e_internal_name       = ls_components-obj_name
      EXCEPTIONS
        type_object_not_valid = 1
        OTHERS                = 2.
    IF sy-subrc NE 0.
      ls_components-obj_name = d_obj_name.
    ENDIF.
    APPEND ls_components TO e_components.


* Se pasan las referencia del objeto a la tabla de componentes
* Uso la estructura base para añadir los campos comunes. Esto simplifica el codigo.
    LOOP AT lt_refs ASSIGNING &lt;ls_refs&gt;.
      ls_components-object = &lt;ls_refs&gt;-type_ref.
* Devuelvo el nombre interno porque para funciones y clases se ha de usar el interno para recuperar los extos.
      IF &lt;ls_refs&gt;-internal_name_ref IS NOT INITIAL.
        ls_components-obj_name = &lt;ls_refs&gt;-internal_name_ref.
      ELSE.
        ls_components-obj_name = &lt;ls_refs&gt;-object_ref.
      ENDIF.
      APPEND ls_components TO e_components.
    ENDLOOP.

* Elimino duplicados, necesario sobretodo en funciones. Ya que lo que se traduce realmente es el
* grupo de funciones. En ese caso, el objeto (grupo de funcion) solo debe aparecer una vez.
    SORT e_components BY object obj_name.
    DELETE ADJACENT DUPLICATES FROM e_components COMPARING object obj_name.

    FREE lo_refs.

  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_OBJECTS_TYPE.
* Function
  APPEND &apos;FUNC&apos; TO r_objects.
* Function group
  APPEND &apos;FUGR&apos; TO r_objects.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_CMP_MESSAGES" VERSION="1" LANGU="E" DESCRIPT="Components: Messages class" UUID="E432DCC4F269A3F180C00050569D8384" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140902" CHANGEDON="20140902" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_CMP" CHANGEDBY="RODIVA01">
  <types CLSNAME="ZTRANS_CMP_MESSAGES" CMPNAME="TY_MESSAGE_KEY" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140902" CHANGEDBY="RODIVA01" CHANGEDON="20140902" TYPTYPE="4" SRCROW1="5 " SRCCOLUMN1="9 " SRCROW2="8 " SRCCOLUMN2="29 " TYPESRC_LENG="138 " TYPESRC="BEGIN OF ty_message_key,
            message_id TYPE sy-msgid,
            message_nr TYPE t100-msgnr,
         END OF ty_message_key
"/>
  <publicSection>class ZTRANS_CMP_MESSAGES definition
  public
  inheriting from ZTRANS_CMP
  final
  create public .

*&quot;* public components of class ZTRANS_CMP_MESSAGES
*&quot;* do not include other source files here!!!
public section.

  methods GET_OBJECTS_TYPE
    redefinition .
  methods GET_COMPONENTS
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_CMP_MESSAGES
*&quot;* do not include other source files here!!!
PROTECTED SECTION.

  TYPES: BEGIN OF ty_message_key,
            message_id TYPE sy-msgid,
            message_nr TYPE t100-msgnr,
         END OF ty_message_key.</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_CMP_MESSAGES
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_CMP_MESSAGES" REFCLSNAME="ZTRANS_CMP" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140902" CHANGEDBY="RODIVA01" CHANGEDON="20140902">
   <redefinition CLSNAME="ZTRANS_CMP_MESSAGES" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_COMPONENTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_MESSAGES" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_OBJECTS_TYPE"/>
  </inheritance>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_components.
  FIELD-SYMBOLS &lt;ls_t100&gt; TYPE t100.
  DATA ls_message_key TYPE ty_message_key.
  DATA lt_t100 TYPE STANDARD TABLE OF t100.
  DATA ls_components TYPE LINE OF ty_t_components.
  DATA ld_masterlang TYPE masterlang.

  CLEAR e_components.

* Busco el idioma original de la clase de mensajes
  SELECT SINGLE masterlang INTO ld_masterlang
         FROM tadir
         WHERE object = d_object
               AND obj_name = d_obj_name.

  IF sy-subrc = 0.

* Se buscan los mensajes en la tabla T100 de la clase de mensajes y con
* el idioma original.
    SELECT * INTO TABLE lt_t100
           FROM t100
           WHERE sprsl = ld_masterlang
                 AND arbgb = d_obj_name.
    IF sy-subrc = 0.

* Se añade cada mensaje individual a la lista de objetos.
      LOOP AT lt_t100 ASSIGNING &lt;ls_t100&gt;.

* Paso a una estructura los datos para construir la clave.
        ls_message_key-message_id = d_obj_name.
        ls_message_key-message_nr = &lt;ls_t100&gt;-msgnr.

* Añado el mensaje
        ls_components-object = &apos;MESS&apos;. &quot; Mensaje individual
        ls_components-obj_name = ls_message_key.
        APPEND ls_components TO e_components.
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_objects_type.
  APPEND &apos;MSAG&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_CMP_SMARTFORMS" VERSION="1" LANGU="E" DESCRIPT="Components: Smartforms" UUID="E3A7C598162CE8F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="20140309" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_CMP" CHANGEDBY="RODIVA01">
  <publicSection>class ZTRANS_CMP_SMARTFORMS definition
  public
  inheriting from ZTRANS_CMP
  final
  create public .

*&quot;* public components of class ZTRANS_CMP_SMARTFORMS
*&quot;* do not include other source files here!!!
public section.

  methods GET_COMPONENTS
    redefinition .
  methods GET_OBJECTS_TYPE
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_CMP_SMARTFORMS
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_CMP_SMARTFORMS
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_CMP_SMARTFORMS" REFCLSNAME="ZTRANS_CMP" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309">
   <redefinition CLSNAME="ZTRANS_CMP_SMARTFORMS" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_COMPONENTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_SMARTFORMS" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_OBJECTS_TYPE"/>
  </inheritance>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_components.
  DATA ls_components TYPE LINE OF ty_t_components.

  CLEAR e_components.

  ls_components-object = d_object.
  ls_components-obj_name = d_obj_name.
  APPEND ls_components TO e_components.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_objects_type.
*  APPEND &apos;SSFO&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE" VERSION="1" LANGU="E" DESCRIPT="LXE" UUID="E3A15FEF4E41ACF196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_PROPOSAL" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140325" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="26 " TYPESRC_LENG="124 " TYPESRC="BEGIN OF ty_proposal.
          INCLUDE TYPE lxe_pcx_s2.
  TYPES: objtype  TYPE lxeobjtype,
         END OF ty_proposal
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_PROPOSAL" VERSION="1" LANGU="E" DESCRIPT="Text Proposals" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140325" TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="51 " TYPESRC_LENG="50 " TYPESRC="ty_t_proposal TYPE STANDARD TABLE OF ty_proposal
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_COLOB" VERSION="1" LANGU="E" DESCRIPT="Object list" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDBY="RODIVA01" CHANGEDON="20140325" TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="46 " TYPESRC_LENG="45 " TYPESRC="ty_t_colob TYPE STANDARD TABLE OF lxe_colob
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_PCX_S1" VERSION="1" LANGU="E" DESCRIPT="Pair text" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140325" TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="48 " TYPESRC_LENG="47 " TYPESRC="ty_t_pcx_s1 type STANDARD TABLE OF lxe_pcx_s1
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_PCX_S2" VERSION="1" LANGU="E" DESCRIPT="Proposal text" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140325" TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="17 " SRCCOLUMN2="48 " R3RELEASE="700" TYPESRC_LENG="47 " TYPESRC="ty_t_pcx_s2 type STANDARD TABLE OF lxe_pcx_s2
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_LXE_LIST" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="34 " TYPESRC_LENG="148 " TYPESRC="BEGIN OF ty_lxe_list,
                    object TYPE trobjtype,
                    class TYPE seoclsname,
                 END OF ty_lxe_list
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_LXE_LIST" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="51 " TYPESRC_LENG="50 " TYPESRC="ty_t_lxe_list TYPE STANDARD TABLE OF ty_lxe_list
"/>
  <types CLSNAME="ZTRANS_LXE" CMPNAME="TY_T_TEXTS" VERSION="1" LANGU="E" DESCRIPT="Texts translated" EXPOSURE="2" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="49 " TYPESRC_LENG="48 " TYPESRC="ty_t_texts TYPE STANDARD TABLE OF ztrans_texts
"/>
  <publicSection>class ZTRANS_LXE definition
  public
  create public .

*&quot;* public components of class ZTRANS_LXE
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .

  types:
    BEGIN OF ty_lxe_list,
                    object TYPE trobjtype,
                    class TYPE seoclsname,
                 END OF ty_lxe_list .
  types:
    ty_t_lxe_list TYPE STANDARD TABLE OF ty_lxe_list .
  types:
    ty_t_texts TYPE STANDARD TABLE OF ztrans_texts .

  methods GET_TEXTS
    exporting
      value(E_TEXTS) type TY_T_TEXTS .
  methods SET_TEXT
    importing
      !I_ID_TEXT type LXETEXTKEY
      !I_OBJTYPE type LXEOBJTYPE
      !I_TEXT type ANY
    exceptions
      ID_TEXT_DONT_EXIST .
  methods SAVE_TEXT
    exceptions
      ERROR_SAVE .
  methods TRANSPORT_TRANSLATE
    importing
      !I_TRKORR type TRKORR
    exceptions
      ERROR_INSERT_TRKORR .
  methods GET_BEST_TEXT_PROPOSAL
    importing
      !I_TEXTKEY type LXETEXTKEY
      !I_OBJTYPE type LXEOBJTYPE
    exporting
      !E_BEST_TEXT type ANY .
  methods IS_TEXT_IN_PROPOSAL
    importing
      !I_TEXT type ANY
      !I_TEXTKEY type LXETEXTKEY
      !I_OBJTYPE type LXEOBJTYPE
    returning
      value(R_EXIST) type SAP_BOOL .
  class-methods GET_LXELIST
    exporting
      !E_LXE_LIST type TY_T_LXE_LIST .
  methods GET_LXE_TYPE
    returning
      value(R_OBJECTS) type OBJTYPTABLE .
  methods SET_CHECK_PARAMS
    importing
      !I_OBJECT type TROBJTYPE
      !I_OBJ_NAME type SOBJ_NAME
      !I_OLANG type LXEISOLANG
      !I_TLANG type LXEISOLANG
    exceptions
      OBJECT_NOT_VALID .
  methods LOAD_TEXT .
  methods HAS_PROPOSED_TEXT
    returning
      value(R_HAS) type SAP_BOOL .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE
*&quot;* do not include other source files here!!!
protected section.

  types:
    BEGIN OF ty_proposal.
          INCLUDE TYPE lxe_pcx_s2.
  TYPES: objtype  TYPE lxeobjtype,
         END OF ty_proposal .
  types:
    ty_t_proposal TYPE STANDARD TABLE OF ty_proposal .
  types:
    ty_t_colob TYPE STANDARD TABLE OF lxe_colob .
  types:
    ty_t_pcx_s1 type STANDARD TABLE OF lxe_pcx_s1 .
  types:
    ty_t_pcx_s2 type STANDARD TABLE OF lxe_pcx_s2 .

  constants DC_STATUS_PROPOSAL type LXEPP_STAT value 09. &quot;#EC NOTEXT
  data D_OBJECT_TEXT type TROBJTYPE .
  data D_OBJECT type TROBJTYPE .
  data D_OBJ_NAME type SOBJ_NAME .
  data D_OLANG type LXEISOLANG .
  data D_TLANG type LXEISOLANG .
  data IT_TEXTS type TY_T_TEXTS .
  data IT_PROPOSAL type TY_T_PROPOSAL .
  data IT_PROPOSAL_BEST type TY_T_PROPOSAL .
  data IT_COLOB type TY_T_COLOB .
  data ET_INFO_OBJECT_OLD type LXE_COLOB .

  methods READ_PROPOSAL
    importing
      !I_T_PCX_S1 type TY_T_PCX_S1
      !I_COLOB type LXE_COLOB
    exporting
      !E_BEST_PROPOSAL type TY_T_PCX_S2
      !E_PROPOSAL type TY_T_PCX_S2 .
  methods PP_CREATE_HASH
    importing
      !I_LANGUAGE type LXEISOLANG
      !I_TEXT type LXEUNITLIN
    exporting
      !E_HASH type LXE_PPHASH
      !E_ENQUEUE type SAP_BOOL
    changing
      !C_PSTATUS type LXESTATPRC .
  methods GET_OBJECT_TEXT
    importing
      !I_OBJECT type TROBJTYPE
      !I_OBJ_NAME type SOBJ_NAME
    returning
      value(R_OBJ_TEXT) type TROBJTYPE .
  methods LOAD_PROPOSAL .
  methods SAVE_PROPOSAL
    importing
      !I_COLOB type LXE_COLOB .
  methods READ_SINGLE_TEXT
    importing
      !I_COLOB type LXE_COLOB
    exporting
      !E_TEXT type TY_T_PCX_S1 .</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_LXE
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZTRANS_LXE" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="DC_STATUS_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Status proposal" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="2" ATTVALUE="09" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXEPP_STAT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="D_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="D_OBJECT_TEXT" VERSION="1" LANGU="4" DESCRIPT="Object text" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="D_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOBJ_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="D_OLANG" VERSION="1" LANGU="4" DESCRIPT="Source Language" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXEISOLANG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="D_TLANG" VERSION="1" LANGU="4" DESCRIPT="Target Language" EXPOSURE="1" STATE="1" EDITORDER="6 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXEISOLANG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="ET_INFO_OBJECT_OLD" VERSION="1" LANGU="4" DESCRIPT="Object Lists" EXPOSURE="1" STATE="1" EDITORDER="11 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXE_COLOB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="IT_COLOB" VERSION="1" LANGU="4" DESCRIPT="Object list" EXPOSURE="1" STATE="1" EDITORDER="10 " AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_COLOB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="IT_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Text proposal" EXPOSURE="1" STATE="1" EDITORDER="8 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_PROPOSAL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="IT_PROPOSAL_BEST" VERSION="1" LANGU="4" DESCRIPT="Best text proposal" EXPOSURE="1" STATE="1" EDITORDER="9 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_PROPOSAL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE" CMPNAME="IT_TEXTS" VERSION="1" LANGU="4" DESCRIPT="Texts translated" EXPOSURE="1" STATE="1" EDITORDER="7 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_TEXTS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_BEST_TEXT_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Get the best text of the proposal" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_BEST_TEXT_PROPOSAL" SCONAME="I_TEXTKEY" VERSION="1" LANGU="4" DESCRIPT="Text Key" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXETEXTKEY"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_BEST_TEXT_PROPOSAL" SCONAME="I_OBJTYPE" VERSION="1" LANGU="4" DESCRIPT="Type of Translation Object" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEOBJTYPE"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_BEST_TEXT_PROPOSAL" SCONAME="E_BEST_TEXT" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>METHOD get_best_text_proposal.
  FIELD-SYMBOLS &lt;ls_proposal&gt; TYPE LINE OF ty_t_proposal.

  CLEAR e_best_text.

  READ TABLE it_proposal_best ASSIGNING &lt;ls_proposal&gt;
       WITH KEY textkey = i_textkey
                objtype = i_objtype.
  IF sy-subrc = 0.
    e_best_text = &lt;ls_proposal&gt;-best_prop.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXELIST" VERSION="1" LANGU="4" DESCRIPT="Get LXE List" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXELIST" SCONAME="E_LXE_LIST" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_LXE_LIST"/>
   <source>METHOD get_lxelist.
  FIELD-SYMBOLS &lt;ls_objects&gt; TYPE LINE OF objtyptable.
  FIELD-SYMBOLS &lt;ls_classlist&gt; TYPE LINE OF seo_inheritances.
  DATA lt_classlist TYPE seo_inheritances.
  DATA ls_lxelist TYPE LINE OF ty_t_lxe_list.
  DATA lt_objects TYPE objtyptable.
  DATA lo_ref TYPE REF TO ztrans_lxe.

  CLEAR e_lxe_list.

* Leo todas las clases que heredan de la clase principal de traducciones.
  SELECT * FROM vseoextend INTO TABLE lt_classlist
    WHERE refclsname = &apos;ZTRANS_LXE&apos;
    AND version = &apos;1&apos;.
  IF sy-subrc = 0.
    LOOP AT lt_classlist ASSIGNING &lt;ls_classlist&gt;.
      ls_lxelist-class = &lt;ls_classlist&gt;-clsname.

* Cualquier excepcion al instanciar la clase o al llamar de sus métodos hará que no se
* tenga en cuenta la clase.
      TRY.

* Se instancia la clase para saber los objetos que puede traducir.
          CREATE OBJECT lo_ref TYPE (ls_lxelist-class).

          lt_objects = lo_ref-&gt;get_lxe_type( ).
          LOOP AT lt_objects ASSIGNING &lt;ls_objects&gt;.
            ls_lxelist-object = &lt;ls_objects&gt;.
            APPEND ls_lxelist TO e_lxe_list.
          ENDLOOP.

        CATCH cx_root.
      ENDTRY.

    ENDLOOP.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="1" LANGU="4" DESCRIPT="Get lxes types" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" SCONAME="R_OBJECTS" VERSION="1" LANGU="4" DESCRIPT="Object Type Table" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="OBJTYPTABLE"/>
   <source>method GET_LXE_TYPE.
endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="1" LANGU="4" DESCRIPT="Get object type of object" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140325" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" SCONAME="I_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" SCONAME="I_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOBJ_NAME"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" SCONAME="R_OBJ_TEXT" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <source>METHOD GET_OBJECT_TEXT.
*DATA ls_ddenq TYPE ddenqs.
*  DATA ls_trkey TYPE trkey.
*  DATA ld_object_class TYPE c LENGTH 10.
*
*  CLEAR r_obj_text.

* Se determina la clase del objeto.
*  CASE i_object.
*    WHEN zif_ref_data~dc_type_program
*         OR zif_ref_data~dc_type_class
*         OR zif_ref_data~dc_type_interface
*         OR zif_ref_data~dc_type_function
*         OR zif_ref_data~dc_type_webdynpro.
*    WHEN zif_ref_data~dc_type_table
*            OR zif_ref_data~dc_type_struc
*            OR zif_ref_data~dc_type_dataelem
*            OR zif_ref_data~dc_type_domain
*            OR zif_ref_data~dc_type_tabltype
*            OR zif_ref_data~dc_type_seahlp
*            OR zif_ref_data~dc_type_view.
*
** Se pasa los datos a una estructura para obtener
*      ls_ddenq-objname = i_obj_name.
*      ls_ddenq-objtype = i_object.
*
*      CALL FUNCTION &apos;RS_CORR_CHECK&apos;
*        EXPORTING
*          object          = ls_ddenq
*          object_class    = &apos;DICT&apos;
*          suppress_dialog = &apos;X&apos;
*        IMPORTING
*          transport_key   = ls_trkey
*        EXCEPTIONS
*          OTHERS          = 1.
*  ENDCASE.

* Tipo de objeto de texto del objeto pasado.
*  r_obj_text = ls_trkey-sub_type.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_TEXTS" VERSION="1" LANGU="4" DESCRIPT="Get texts" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="GET_TEXTS" SCONAME="E_TEXTS" VERSION="1" LANGU="4" DESCRIPT="Texts translated" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_T_TEXTS"/>
   <source>METHOD GET_TEXTS.
  e_texts = it_texts.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="1" LANGU="E" DESCRIPT="The object has proposed text?" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" SCONAME="R_HAS" VERSION="1" LANGU="E" DESCRIPT="Boolean Variable (X=True, Space=False)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SAP_BOOL"/>
   <source>method HAS_PROPOSED_TEXT.
endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="IS_TEXT_IN_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Is the text in the proposal&apos;s pool" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="IS_TEXT_IN_PROPOSAL" SCONAME="I_TEXT" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="IS_TEXT_IN_PROPOSAL" SCONAME="I_TEXTKEY" VERSION="1" LANGU="4" DESCRIPT="Text Key" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXETEXTKEY"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="IS_TEXT_IN_PROPOSAL" SCONAME="I_OBJTYPE" VERSION="1" LANGU="4" DESCRIPT="Type of Translation Object" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140316" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEOBJTYPE"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="IS_TEXT_IN_PROPOSAL" SCONAME="R_EXIST" VERSION="1" LANGU="4" DESCRIPT="Boolean Variable (X=True, Space=False)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140316" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SAP_BOOL"/>
   <source>METHOD IS_TEXT_IN_PROPOSAL.
  FIELD-SYMBOLS &lt;ls_proposal&gt; TYPE LINE OF ty_t_proposal.
  r_exist = abap_false.

  READ TABLE it_proposal ASSIGNING &lt;ls_proposal&gt; WITH KEY textkey = i_textkey
                                                          objtype = i_objtype
                                                          best_prop = i_text.
  IF sy-subrc = 0.
* El status &apos;00&apos; significa que hay una propuesta pero no esta confirmada para el texto.
    IF &lt;ls_proposal&gt;-status NE &apos;00&apos;.
      r_exist = abap_true.
    ENDIF.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="LOAD_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Load proposal" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD LOAD_PROPOSAL.
*  FIELD-SYMBOLS &lt;ls_texts&gt; LIKE LINE OF it_texts.
*  FIELD-SYMBOLS &lt;ls_pp&gt; TYPE lxe_pp___1.
*  DATA ld_status TYPE lxestatprc.
*  DATA ls_proposal TYPE LINE OF TY_T_PROPOSAL.
*  DATA ld_ohash TYPE lxe_pphash.
*  DATA ld_thash TYPE lxe_pphash.
*  DATA lt_pp TYPE STANDARD TABLE OF lxe_pp___1.
*  DATA lt_ppa TYPE STANDARD TABLE OF lxe_ppa__1.
*  DATA ls_hash TYPE lxe_pphash.
*
*  CLEAR: it_proposal, it_proposal_best.
*
** Los textos tienen que estar para poder leer la propuesta.
*  IF it_texts IS NOT INITIAL.
** Obtengo la mejor propuesta de los textos.
*      CALL FUNCTION &apos;LXE_PP1_PROPOSALS_GET&apos;
*        EXPORTING
*          s_lang    = d_olang
*          t_lang    = d_tlang
*          custmnr   = et_info_object-custmnr
*          objtype   = et_info_object-objtype
*          domatyp   = d_domatyp
*          domanam   = d_domanam
*        IMPORTING
*          pstatus   = ld_status
*        TABLES
*          lt_pcx_s1 = it_texts
*          lt_pcx_s2 = it_proposal_best.
*
*
** De cada texto obtengo sus propuestas. No hay una funcion que sea como la anterior que
** devuelva todas las propuestas bien formateadas. Por ello, tengo que replicarlo como hace SAP
** pero ajustando a la tabla de mejores propuestas.
*      LOOP AT it_texts ASSIGNING &lt;ls_texts&gt;.
*        CLEAR lt_pp.
*
*        CALL FUNCTION &apos;LXE_PP1_HASH_CREATE&apos;
*          EXPORTING
*            language       = d_olang
*            text           = &lt;ls_texts&gt;-s_text
*          IMPORTING
*            hash           = ld_ohash
*          EXCEPTIONS
*            internal_error = 1
*            OTHERS         = 2.
*
*        CALL FUNCTION &apos;LXE_PP1_PP_READ_DB_APPLIC&apos;
*          EXPORTING
*            s_lang         = d_olang
*            t_lang         = d_tlang
*            domatyp        = &apos;*&apos;
*            domanam        = &apos;* &apos;
*            hash           = ld_ohash
*            no_zero        = &apos;&apos;
*          TABLES
*            t_pp           = lt_pp
*            t_ppa          = lt_ppa
*          EXCEPTIONS
*            internal_error = 1
*            OTHERS         = 2.
*
*        LOOP AT lt_pp ASSIGNING &lt;ls_pp&gt;.
*          ls_proposal-status = &lt;ls_pp&gt;-status.
*          ls_proposal-textkey = &lt;ls_texts&gt;-textkey.
*          ls_proposal-cnt_prop = &lt;ls_pp&gt;-var_cnt.
*
*          ls_hash-language = d_tlang.
*          ls_hash-hash_1 = &lt;ls_pp&gt;-t_hash_1.
*          ls_hash-hash_2 = &lt;ls_pp&gt;-t_hash_2.
*          ls_hash-hash_3 = &lt;ls_pp&gt;-t_hash_3.
*          ls_hash-hash_4 = &lt;ls_pp&gt;-t_hash_4.
*          ls_hash-hash_5 = &lt;ls_pp&gt;-t_hash_5.
*          ls_hash-hash_6 = &lt;ls_pp&gt;-t_hash_6.
*
*          CALL FUNCTION &apos;LXE_PP1_TEXT_GET&apos;
*            EXPORTING
*              hash      = ls_hash
*            IMPORTING
*              text      = ls_proposal-best_prop
*            EXCEPTIONS
*              not_found = 1
*              OTHERS    = 2.
*
*          IF sy-subrc = 0.
*            APPEND ls_proposal TO it_proposal.
*            CLEAR ls_proposal.
*          ENDIF.
*        ENDLOOP.
*      ENDLOOP.
*
*  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="LOAD_TEXT" VERSION="1" LANGU="4" DESCRIPT="Load text" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD load_text.
  FIELD-SYMBOLS &lt;ls_colob&gt; TYPE lxe_colob.
  FIELD-SYMBOLS &lt;ls_lxe_texts&gt; TYPE lxe_pcx_s1.
  FIELD-SYMBOLS &lt;ls_pcx_s2&gt; TYPE LINE OF ty_t_pcx_s2.
  DATA lt_lxe_texts TYPE STANDARD TABLE OF lxe_pcx_s1.
  DATA ls_texts TYPE LINE OF ty_t_texts.
  DATA lt_best_pcx_s2 TYPE ty_t_pcx_s2.
  DATA lt_pcx_s2 TYPE ty_t_pcx_s2.
  DATA ls_proposal TYPE LINE OF ty_t_proposal.

  CLEAR: it_texts, it_proposal, it_proposal_best.

* Un objeto puede tener tipos de textos a traducir.
  LOOP AT it_colob ASSIGNING &lt;ls_colob&gt;.

* Se convierte, para objetos antiguos, el objeto a traducic.r
    CALL FUNCTION &apos;LXE_OBJ_CONVERT_OL_WLB&apos;
      EXPORTING
        in_custmnr = &lt;ls_colob&gt;-custmnr
        in_objtype = &lt;ls_colob&gt;-objtype
        in_objname = &lt;ls_colob&gt;-objname
      IMPORTING
        custmnr    = &lt;ls_colob&gt;-custmnr
        objtype    = &lt;ls_colob&gt;-objtype
        objname    = &lt;ls_colob&gt;-objname.

* Lectura del texto según el registro que se lee la tabla de tipos de textos
* del objeto
    CALL METHOD read_single_text
      EXPORTING
        i_colob = &lt;ls_colob&gt;
      IMPORTING
        e_text  = lt_lxe_texts.

* Paso los textos leídos de SAP a la tabla general.
    LOOP AT lt_lxe_texts ASSIGNING &lt;ls_lxe_texts&gt;.
      MOVE-CORRESPONDING &lt;ls_lxe_texts&gt; TO ls_texts.
      ls_texts-objtype = &lt;ls_colob&gt;-objtype.
      APPEND ls_texts TO it_texts.
      CLEAR ls_texts.
    ENDLOOP.
    IF sy-subrc = 0.

* Leo la propuestas de los textos obtenidos
      CALL METHOD read_proposal
        EXPORTING
          i_t_pcx_s1      = lt_lxe_texts
          i_colob         = &lt;ls_colob&gt;
        IMPORTING
          e_best_proposal = lt_best_pcx_s2
          e_proposal      = lt_pcx_s2.

* Se añaden las propuestas a las tablas globales.
      LOOP AT lt_best_pcx_s2 ASSIGNING &lt;ls_pcx_s2&gt;.
        MOVE-CORRESPONDING &lt;ls_pcx_s2&gt; TO ls_proposal.
        ls_proposal-objtype = &lt;ls_colob&gt;-objtype.
        APPEND ls_proposal TO it_proposal_best.
        CLEAR ls_proposal.
      ENDLOOP.
      LOOP AT lt_pcx_s2 ASSIGNING &lt;ls_pcx_s2&gt;.
        MOVE-CORRESPONDING &lt;ls_pcx_s2&gt; TO ls_proposal.
        ls_proposal-objtype = &lt;ls_colob&gt;-objtype.
        APPEND ls_proposal TO it_proposal.
        CLEAR ls_proposal.
      ENDLOOP.
    ENDIF.

    CLEAR: lt_lxe_texts, lt_pcx_s2, lt_best_pcx_s2.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" VERSION="1" LANGU="4" DESCRIPT="Proposal: Create Hash" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" SCONAME="I_LANGUAGE" VERSION="1" LANGU="4" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" SCONAME="I_TEXT" VERSION="1" LANGU="4" DESCRIPT="Translation Unit for Short Text (Line)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEUNITLIN"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" SCONAME="E_HASH" VERSION="1" LANGU="4" DESCRIPT="Hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="LXE_PPHASH"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" SCONAME="E_ENQUEUE" VERSION="1" LANGU="4" DESCRIPT="Boolean Variable (X=True, Space=False)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SAP_BOOL"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="PP_CREATE_HASH" SCONAME="C_PSTATUS" VERSION="1" LANGU="4" DESCRIPT="Process Status" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="LXESTATPRC"/>
   <source>METHOD PP_CREATE_HASH.
  CLEAR: e_hash.
  e_enqueue = abap_false.
  c_pstatus = &apos;S&apos;. &quot; Ok

  CALL FUNCTION &apos;LXE_PP1_HASH_CREATE&apos;
    EXPORTING
      language       = i_language
      text           = i_text
      insert_db      = &apos;X&apos;
    IMPORTING
      hash           = e_hash
      enq_commit     = e_enqueue
    EXCEPTIONS
      internal_error = 1
      OTHERS         = 2.
  IF sy-subrc NE 0.
    c_pstatus = &apos;F&apos;.
  ELSE.
    IF e_enqueue = abap_true.
      COMMIT WORK.
    ELSE.
      CALL FUNCTION &apos;ENQUEUE_E_LXETXT&apos;
        EXPORTING
          mode_lxetxt0020 = &apos;E&apos;
          language        = e_hash-language
          hash_1          = e_hash-hash_1
          hash_2          = e_hash-hash_2
          hash_3          = e_hash-hash_3
          hash_4          = e_hash-hash_4
          hash_5          = e_hash-hash_5
          _wait           = &apos;X&apos;
        EXCEPTIONS
          foreign_lock    = 1
          system_failure  = 2
          OTHERS          = 3.
      IF sy-subrc &lt;&gt; 0.
        c_pstatus = &apos;F&apos;.
      ELSE.
        e_enqueue = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDIF.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="READ_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Read proposal of a text" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_PROPOSAL" SCONAME="I_T_PCX_S1" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_PCX_S1"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_PROPOSAL" SCONAME="I_COLOB" VERSION="1" LANGU="4" DESCRIPT="Object Lists" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXE_COLOB"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_PROPOSAL" SCONAME="E_BEST_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Text Proposals" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_PCX_S2"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_PROPOSAL" SCONAME="E_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Text Proposals" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_PCX_S2"/>
   <source>METHOD read_proposal.
  FIELD-SYMBOLS &lt;ls_texts&gt; TYPE lxe_pcx_s1.
  FIELD-SYMBOLS &lt;ls_pp&gt; TYPE lxe_pp___1.
  DATA ld_domatyp TYPE lxedomatyp .
  DATA ld_domanam TYPE lxedomanam .
  DATA ld_status TYPE lxestatprc.
  DATA ls_proposal TYPE LINE OF ty_t_proposal.
  DATA ld_ohash TYPE lxe_pphash.
  DATA ld_thash TYPE lxe_pphash.
  DATA lt_pp TYPE STANDARD TABLE OF lxe_pp___1.
  DATA lt_ppa TYPE STANDARD TABLE OF lxe_ppa__1.
  DATA ls_hash TYPE lxe_pphash.


  CLEAR: e_best_proposal, e_proposal.

* Los textos tienen que estar para poder leer la propuesta.
  IF i_t_pcx_s1 IS NOT INITIAL.

* Leo los atributos del objeto para obtener la propuesta.
    CALL FUNCTION &apos;LXE_OBJ_GET_TECH_INFO&apos;
      EXPORTING
        custmnr       = i_colob-custmnr
        objtype       = i_colob-objtype
        objname       = i_colob-objname
        bypass_buffer = &apos;X&apos;
      IMPORTING
        domatyp       = ld_domatyp
        domanam       = ld_domanam.

* Obtengo la mejor propuesta de los textos.
    CALL FUNCTION &apos;LXE_PP1_PROPOSALS_GET&apos;
      EXPORTING
        s_lang    = d_olang
        t_lang    = d_tlang
        custmnr   = i_colob-custmnr
        objtype   = i_colob-objtype
        domatyp   = ld_domatyp
        domanam   = ld_domanam
      IMPORTING
        pstatus   = ld_status
      TABLES
        lt_pcx_s1 = i_t_pcx_s1[]
        lt_pcx_s2 = e_best_proposal[].

* De cada texto obtengo sus propuestas. No hay una funcion que sea como la anterior que
* devuelva todas las propuestas bien formateadas. Por ello, tengo que replicarlo como hace SAP
* pero ajustando a la tabla de mejores propuestas.
    LOOP AT i_t_pcx_s1 ASSIGNING &lt;ls_texts&gt;.
      CLEAR lt_pp.

      CALL FUNCTION &apos;LXE_PP1_HASH_CREATE&apos;
        EXPORTING
          language       = d_olang
          text           = &lt;ls_texts&gt;-s_text
        IMPORTING
          hash           = ld_ohash
        EXCEPTIONS
          internal_error = 1
          OTHERS         = 2.

      CALL FUNCTION &apos;LXE_PP1_PP_READ_DB_APPLIC&apos;
        EXPORTING
          s_lang         = d_olang
          t_lang         = d_tlang
          domatyp        = &apos;*&apos;
          domanam        = &apos;* &apos;
          hash           = ld_ohash
          no_zero        = &apos;&apos;
        TABLES
          t_pp           = lt_pp
          t_ppa          = lt_ppa
        EXCEPTIONS
          internal_error = 1
          OTHERS         = 2.

      LOOP AT lt_pp ASSIGNING &lt;ls_pp&gt;.
        ls_proposal-status = &lt;ls_pp&gt;-status.
        ls_proposal-textkey = &lt;ls_texts&gt;-textkey.
        ls_proposal-cnt_prop = &lt;ls_pp&gt;-var_cnt.

        ls_hash-language = d_tlang.
        ls_hash-hash_1 = &lt;ls_pp&gt;-t_hash_1.
        ls_hash-hash_2 = &lt;ls_pp&gt;-t_hash_2.
        ls_hash-hash_3 = &lt;ls_pp&gt;-t_hash_3.
        ls_hash-hash_4 = &lt;ls_pp&gt;-t_hash_4.
        ls_hash-hash_5 = &lt;ls_pp&gt;-t_hash_5.
        ls_hash-hash_6 = &lt;ls_pp&gt;-t_hash_6.

        CALL FUNCTION &apos;LXE_PP1_TEXT_GET&apos;
          EXPORTING
            hash      = ls_hash
          IMPORTING
            text      = ls_proposal-best_prop
          EXCEPTIONS
            not_found = 1
            OTHERS    = 2.

        IF sy-subrc = 0.
          APPEND ls_proposal TO e_proposal.
          CLEAR ls_proposal.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="READ_SINGLE_TEXT" VERSION="1" LANGU="4" DESCRIPT="Read single text" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_SINGLE_TEXT" SCONAME="I_COLOB" VERSION="1" LANGU="4" DESCRIPT="Object Lists" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXE_COLOB"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="READ_SINGLE_TEXT" SCONAME="E_TEXT" VERSION="1" LANGU="4" DESCRIPT="Pair texts" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140309" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_PCX_S1"/>
   <source>METHOD read_single_text.

  CLEAR e_text.

* Se llama a la función que cubre el 80% o de traducciones. Para objetos
* especificos se sobrecarga el método y se cambia.
  CALL FUNCTION &apos;LXE_OBJ_TEXT_PAIR_READ&apos;
    EXPORTING
      t_lang    = d_tlang
      s_lang    = d_olang
      custmnr   = i_colob-custmnr
      objtype   = i_colob-objtype
      objname   = i_colob-objname
      read_only = space
    TABLES
      lt_pcx_s1 = e_text[].

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SAVE_PROPOSAL" VERSION="1" LANGU="4" DESCRIPT="Save the proposal" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SAVE_PROPOSAL" SCONAME="I_COLOB" VERSION="1" LANGU="4" DESCRIPT="Object Lists" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXE_COLOB"/>
   <source>METHOD save_proposal.
  FIELD-SYMBOLS &lt;ls_texts&gt; LIKE LINE OF it_texts.
  DATA ld_pstatus TYPE lxestatprc.
  DATA ls_t_hash TYPE lxe_pphash.
  DATA ld_t_enq TYPE c.
  DATA ls_s_hash TYPE lxe_pphash.
  DATA ld_s_enq TYPE c.
  DATA ld_enq TYPE c.
  DATA ls_proposal TYPE LINE OF ty_t_proposal.
  DATA ld_domatyp TYPE lxedomatyp .
  DATA ld_domanam TYPE lxedomanam .

* Solo se graban como propuestas aquellos textos que no existen
* en la tabla de propuestas
  LOOP AT it_texts ASSIGNING &lt;ls_texts&gt; WHERE t_text IS NOT INITIAL
                                              AND objtype = i_colob-objtype.

    READ TABLE it_proposal TRANSPORTING NO FIELDS WITH KEY textkey = &lt;ls_texts&gt;-textkey
                                                           objtype = &lt;ls_texts&gt;-objtype
                                                            best_prop = &lt;ls_texts&gt;-t_text.
    IF sy-subrc NE 0.

* Añado el nuevo texto a la tabla de propuestas
      ls_proposal-textkey = &lt;ls_texts&gt;-textkey.
      ls_proposal-objtype = &lt;ls_texts&gt;-objtype.
      ls_proposal-best_prop = &lt;ls_texts&gt;-t_text.
      ls_proposal-status = dc_status_proposal.
      APPEND ls_proposal TO it_proposal.

* Leo los atributos del objeto para poder grabar la propuesta de texto
      CALL FUNCTION &apos;LXE_OBJ_GET_TECH_INFO&apos;
        EXPORTING
          custmnr       = i_colob-custmnr
          objtype       = i_colob-objtype
          objname       = i_colob-objname
          bypass_buffer = &apos;X&apos;
        IMPORTING
          domatyp       = ld_domatyp
          domanam       = ld_domanam.

      ld_pstatus = &apos;S&apos;. &quot; Proceso correcto.

* Se crea el HASH en base de datos del texto destino.
      CALL METHOD pp_create_hash
        EXPORTING
          i_language = d_tlang
          i_text     = &lt;ls_texts&gt;-t_text
        IMPORTING
          e_hash     = ls_t_hash
          e_enqueue  = ld_t_enq
        CHANGING
          c_pstatus  = ld_pstatus.


      IF ld_pstatus = &apos;S&apos;. &quot; Si todo correcto se continua el proceso.

* Lo mismo para el texto de origen
        CALL METHOD pp_create_hash
          EXPORTING
            i_language = d_olang
            i_text     = &lt;ls_texts&gt;-s_text
          IMPORTING
            e_hash     = ls_s_hash
            e_enqueue  = ld_s_enq
          CHANGING
            c_pstatus  = ld_pstatus.

        IF ld_pstatus = &apos;S&apos;. &quot; Si todo correcto se continua.
* Finalmente se crea la propuesta con el status &apos;09&apos;.
          CALL FUNCTION &apos;LXE_PP1_APPLIC_CREATE&apos;
            EXPORTING
              t_lang         = d_tlang
              s_lang         = d_olang
              domatyp        = ld_domatyp
              domanam        = ld_domanam
              s_hash         = ls_s_hash
              t_hash         = ls_t_hash
              status         = dc_status_proposal
            IMPORTING
              enq_commit     = ld_enq
            EXCEPTIONS
              internal_error = 1
              OTHERS         = 2.
          IF sy-subrc = 0 AND ld_enq = abap_true.
            COMMIT WORK.
            CALL FUNCTION &apos;DEQUEUE_E_LXE_PP&apos;
              EXPORTING
                t_lang   = d_tlang
                s_lang   = d_olang
                s_hash_1 = ls_s_hash-hash_1
                s_hash_2 = ls_s_hash-hash_2
                s_hash_3 = ls_s_hash-hash_3
                s_hash_4 = ls_s_hash-hash_4
                s_hash_5 = ls_s_hash-hash_5.
          ENDIF.
        ENDIF.
      ENDIF.

* Se desbloquean los HASH de los textos
      IF ld_t_enq = abap_true.
        CALL FUNCTION &apos;DEQUEUE_E_LXETXT&apos;
          EXPORTING
            language = ls_t_hash-language
            hash_1   = ls_t_hash-hash_1
            hash_2   = ls_t_hash-hash_2
            hash_3   = ls_t_hash-hash_3
            hash_4   = ls_t_hash-hash_4
            hash_5   = ls_t_hash-hash_5.
      ENDIF.
      IF ld_s_enq = abap_true.
        CALL FUNCTION &apos;DEQUEUE_E_LXETXT&apos;
          EXPORTING
            language = ls_s_hash-language
            hash_1   = ls_s_hash-hash_1
            hash_2   = ls_s_hash-hash_2
            hash_3   = ls_s_hash-hash_3
            hash_4   = ls_s_hash-hash_4
            hash_5   = ls_s_hash-hash_5.
      ENDIF.

    ENDIF.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SAVE_TEXT" VERSION="1" LANGU="4" DESCRIPT="Save text" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZTRANS_LXE" CMPNAME="SAVE_TEXT" SCONAME="ERROR_SAVE" VERSION="1" LANGU="4" DESCRIPT="Error save texts" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000"/>
   <source>METHOD save_text.
  FIELD-SYMBOLS &lt;ls_colob&gt; TYPE lxe_colob.
  FIELD-SYMBOLS &lt;ls_texts&gt; TYPE LINE OF ty_t_texts.
  DATA ld_status TYPE lxestatprc.
  DATA lt_lxe_texts TYPE STANDARD TABLE OF lxe_pcx_s1.
  DATA ls_lxe_texts TYPE lxe_pcx_s1.

* La tabla de textos principal contiene todos los posibles
* textos que puede tener un objeto. Para poder grabar hay
* hacerlo por cada tipo. Por eso hay que separalos.
  LOOP AT it_colob ASSIGNING &lt;ls_colob&gt;.

    CLEAR lt_lxe_texts.
    LOOP AT it_texts ASSIGNING &lt;ls_texts&gt; WHERE objtype = &lt;ls_colob&gt;-objtype.
      MOVE-CORRESPONDING &lt;ls_texts&gt; TO ls_lxe_texts.
      APPEND ls_lxe_texts TO lt_lxe_texts.
    ENDLOOP.
    IF sy-subrc = 0.

* Antes de grabar hay que leer de nuevo los objetos para que se carguen tablas intermedias
* del grupo de funciones estándar.
      read_single_text( i_colob = &lt;ls_colob&gt; ).

      CALL FUNCTION &apos;LXE_OBJ_TEXT_PAIR_WRITE&apos;
        EXPORTING
          t_lang    = d_tlang
          s_lang    = d_olang
          custmnr   = &lt;ls_colob&gt;-custmnr
          objtype   = &lt;ls_colob&gt;-objtype
          objname   = &lt;ls_colob&gt;-objname
        IMPORTING
          pstatus   = ld_status
        TABLES
          lt_pcx_s1 = lt_lxe_texts.

      IF ld_status = &apos;F&apos;.
        RAISE error_save.
      ENDIF.

* Se graban las propuestas
      save_proposal( i_colob = &lt;ls_colob&gt; ).

    ENDIF.
  ENDLOOP.


ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" VERSION="1" LANGU="4" DESCRIPT="Set and check params" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140309" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" SCONAME="I_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" SCONAME="I_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOBJ_NAME"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" SCONAME="I_OLANG" VERSION="1" LANGU="4" DESCRIPT="Source Language" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" SCONAME="I_TLANG" VERSION="1" LANGU="4" DESCRIPT="Target Language" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <exception CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" SCONAME="OBJECT_NOT_VALID" VERSION="1" LANGU="4" DESCRIPT="Object not valid" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000"/>
   <source>METHOD SET_CHECK_PARAMS.
  DATA ls_e071 TYPE LINE OF tr_objects.
  DATA lt_e071_text TYPE tr_objects .
  DATA lt_e071k_text TYPE tr_keys .

* Guardo los parametros pasados a variables globales.
  d_object = i_object.
  d_obj_name = i_obj_name.
  d_olang = i_olang.
  d_tlang = i_tlang.

  d_object_text = get_object_text( i_object = i_object
                                 i_obj_name = i_obj_name ).

* Si no se puede determinar el tipo de objeto del texto se lanza una
* excepcion.
  IF d_object_text IS NOT INITIAL.

* Se rellena una tabla interna (e071 la que contiene los objetos en las tareas) para poder la
* informacion para el transporte
    ls_e071-pgmid = &apos;LIMU&apos;.
    ls_e071-object = d_object_text.
    ls_e071-obj_name = i_obj_name.
    APPEND ls_e071 TO lt_e071_text.

* Se obtiene la informacion para obtener los datos traduccion en base a los datos de la tabla de transporte.
    CALL FUNCTION &apos;LXE_OBJ_EXPAND_TRANSPORT&apos;
      TABLES
        in_e071  = lt_e071_text
        in_e071k = lt_e071k_text
        ex_colob = it_colob.

    IF it_colob IS INITIAL.
      RAISE object_not_valid.
    ENDIF.

  ELSE.
    RAISE object_not_valid.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SET_TEXT" VERSION="1" LANGU="4" DESCRIPT="Set text of a ID" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_TEXT" SCONAME="I_ID_TEXT" VERSION="1" LANGU="4" DESCRIPT="Text Key" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXETEXTKEY"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_TEXT" SCONAME="I_OBJTYPE" VERSION="1" LANGU="4" DESCRIPT="Type of Translation Object" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEOBJTYPE"/>
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="SET_TEXT" SCONAME="I_TEXT" VERSION="1" LANGU="4" DESCRIPT="Translation Unit for Short Text (Line)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZTRANS_LXE" CMPNAME="SET_TEXT" SCONAME="ID_TEXT_DONT_EXIST" VERSION="1" LANGU="4" DESCRIPT="Id Text dont exist" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000"/>
   <source>METHOD SET_TEXT.
  FIELD-SYMBOLS &lt;ls_texts&gt; TYPE LINE OF ty_t_texts.

  READ TABLE it_texts ASSIGNING &lt;ls_texts&gt; WITH KEY textkey = i_id_text
                                                    objtype = i_objtype.
  IF sy-subrc = 0.
    &lt;ls_texts&gt;-t_text = i_text.
  ELSE.
    RAISE id_text_dont_exist.
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="TRANSPORT_TRANSLATE" VERSION="1" LANGU="4" DESCRIPT="Transport de translate to transport request" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_LXE" CMPNAME="TRANSPORT_TRANSLATE" SCONAME="I_TRKORR" VERSION="1" LANGU="4" DESCRIPT="Request/Task" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR"/>
   <exception CLSNAME="ZTRANS_LXE" CMPNAME="TRANSPORT_TRANSLATE" SCONAME="ERROR_INSERT_TRKORR" VERSION="1" LANGU="4" DESCRIPT="Error to insert trkorr" MTDTYPE="0" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000"/>
   <source>METHOD transport_translate.
  FIELD-SYMBOLS &lt;ls_colob&gt; TYPE lxe_colob.
  DATA lt_e071k TYPE STANDARD TABLE OF e071k.
  DATA ls_e071k TYPE e071k.
  DATA lt_e071 TYPE STANDARD TABLE OF e071.
  DATA ls_e071 TYPE e071.
  DATA ld_lang TYPE spras.

* Se convierte el idioma del sistema de traduccio a idioma R/3
* para ponerlo en la orden.
  CALL FUNCTION &apos;LXE_T002_CHECK_LANGUAGE&apos;
    EXPORTING
      language           = d_tlang
    IMPORTING
      o_r3_lang          = ld_lang
    EXCEPTIONS
      language_not_in_cp = 1
      unknown            = 2
      OTHERS             = 3.

  LOOP AT it_colob ASSIGNING &lt;ls_colob&gt;.

* Llamo a la funcion que pasandole el objeto me genera las entradas en las tablas
* E071 y E071K para pasarla a la orden de transporte.
    CALL FUNCTION &apos;LXE_OBJ_CREATE_TRANSPORT_SE63&apos;
      EXPORTING
        language = ld_lang
        custmnr  = &lt;ls_colob&gt;-custmnr
        objtype  = &lt;ls_colob&gt;-objtype
        objname  = &lt;ls_colob&gt;-objname
      TABLES
        ex_e071  = lt_e071[]
        ex_e071k = lt_e071k[].

    IF lt_e071 IS NOT INITIAL.

      CALL FUNCTION &apos;TR_APPEND_TO_COMM_OBJS_KEYS&apos;
        EXPORTING
          wi_simulation                  = &apos; &apos;
          wi_suppress_key_check          = &apos; &apos;
          wi_trkorr                      = i_trkorr
        TABLES
          wt_e071                        = lt_e071[]
          wt_e071k                       = lt_e071k[]
        EXCEPTIONS
          key_char_in_non_char_field     = 1
          key_check_keysyntax_error      = 2
          key_inttab_table               = 3
          key_longer_field_but_no_generc = 4
          key_missing_key_master_fields  = 5
          key_missing_key_tablekey       = 6
          key_non_char_but_no_generic    = 7
          key_no_key_fields              = 8
          key_string_longer_char_key     = 9
          key_table_has_no_fields        = 10
          key_table_not_activ            = 11
          key_unallowed_key_function     = 12
          key_unallowed_key_object       = 13
          key_unallowed_key_objname      = 14
          key_unallowed_key_pgmid        = 15
          key_without_header             = 16
          ob_check_obj_error             = 17
          ob_devclass_no_exist           = 18
          ob_empty_key                   = 19
          ob_generic_objectname          = 20
          ob_ill_delivery_transport      = 21
          ob_ill_lock                    = 22
          ob_ill_parts_transport         = 23
          ob_ill_source_system           = 24
          ob_ill_system_object           = 25
          ob_ill_target                  = 26
          ob_inttab_table                = 27
          ob_local_object                = 28
          ob_locked_by_other             = 29
          ob_modif_only_in_modif_order   = 30
          ob_name_too_long               = 31
          ob_no_append_of_corr_entry     = 32
          ob_no_append_of_c_member       = 33
          ob_no_consolidation_transport  = 34
          ob_no_original                 = 35
          ob_no_shared_repairs           = 36
          ob_no_systemname               = 37
          ob_no_systemtype               = 38
          ob_no_tadir                    = 39
          ob_no_tadir_not_lockable       = 40
          ob_privat_object               = 41
          ob_repair_only_in_repair_order = 42
          ob_reserved_name               = 43
          ob_syntax_error                = 44
          ob_table_has_no_fields         = 45
          ob_table_not_activ             = 46
          tr_enqueue_failed              = 47
          tr_errors_in_error_table       = 48
          tr_ill_korrnum                 = 49
          tr_lockmod_failed              = 50
          tr_lock_enqueue_failed         = 51
          tr_not_owner                   = 52
          tr_no_systemname               = 53
          tr_no_systemtype               = 54
          tr_order_not_exist             = 55
          tr_order_released              = 56
          tr_order_update_error          = 57
          tr_wrong_order_type            = 58
          ob_invalid_target_system       = 59
          tr_no_authorization            = 60
          ob_wrong_tabletyp              = 61
          ob_wrong_category              = 62
          ob_system_error                = 63
          ob_unlocal_objekt_in_local_ord = 64
          tr_wrong_client                = 65
          ob_wrong_client                = 66
          key_wrong_client               = 67
          OTHERS                         = 68.

      IF sy-subrc NE 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 RAISING error_insert_trkorr.

      ENDIF.
    ENDIF.
    CLEAR: lt_e071, lt_e071k.
  ENDLOOP.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_CLASSES" VERSION="1" LANGU="E" DESCRIPT="LXE: Classes plugin" UUID="E3A15E4481C2F0F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE">
  <publicSection>class ZTRANS_LXE_CLASSES definition
  public
  inheriting from ZTRANS_LXE
  create public .

*&quot;* public components of class ZTRANS_LXE_CLASSES
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_CLASSES
*&quot;* do not include other source files here!!!
protected section.

  methods GET_OBJECT_TEXT
    redefinition .</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02705
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_LXE_CLASSES" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_CLASSES" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_CLASSES" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_OBJECT_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_CLASSES" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_LXE_TYPE.
* Clases
  APPEND &apos;CLAS&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_OBJECT_TEXT.
  DATA ld_objtyp   TYPE e071-object.
  DATA ld_pgmid    TYPE e071-pgmid.
  DATA ld_obj_name TYPE e071-obj_name.

  PERFORM determine_lock_key IN PROGRAM SAPLSEUQ USING    space
                                        &apos;TEXT&apos;
                                        i_obj_name
                               CHANGING ld_pgmid
                                        ld_objtyp
                                        ld_obj_name.

* Tipo de objeto de texto del objeto pasado.
  r_obj_text = ld_objtyp.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_true.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_DDIC" VERSION="1" LANGU="E" DESCRIPT="LXE: Dictionary" UUID="E3A315AB686E84F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDON="20140907" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE" CHANGEDBY="RODIVA01">
  <publicSection>class ZTRANS_LXE_DDIC definition
  public
  inheriting from ZTRANS_LXE
  final
  create public .

*&quot;* public components of class ZTRANS_LXE_DDIC
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_DDIC
*&quot;* do not include other source files here!!!
protected section.

  methods GET_OBJECT_TEXT
    redefinition .</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_LXE_DDIC
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_LXE_DDIC" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_DDIC" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_DDIC" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_OBJECT_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_DDIC" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_lxe_type.
* Tables
  APPEND &apos;TABL&apos; TO r_objects.
* Data elements
  APPEND &apos;DTEL&apos; TO r_objects.
* Domain
  APPEND &apos;DOMA&apos; TO r_objects.
* Structure
  APPEND &apos;STRU&apos; TO r_objects.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_object_text.
  DATA ls_ddenq TYPE ddenqs.
  DATA ld_objtyp   TYPE e071-object.
  DATA ld_pgmid    TYPE e071-pgmid.
  DATA ld_obj_name TYPE e071-obj_name.

* Se pasa los datos a una estructura para obtener el objeto de texto.
  ls_ddenq-objname = i_obj_name.
  ls_ddenq-objtype = i_object.


  PERFORM determine_lock_key IN PROGRAM SAPLSEUQ USING    space
                                        &apos;DICT&apos;
                                        ls_ddenq
                               CHANGING ld_pgmid
                                        ld_objtyp
                                        ld_obj_name.

* Tipo de objeto de texto del objeto pasado.
  r_obj_text = ld_objtyp.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_true.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_FUNCTION_GROUP" VERSION="1" LANGU="E" DESCRIPT="LXE: Function group" UUID="E3A3121ED83597F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDON="20140907" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE" CHANGEDBY="RODIVA01">
  <publicSection>class ZTRANS_LXE_FUNCTION_GROUP definition
  public
  inheriting from ZTRANS_LXE
  final
  create public .

*&quot;* public components of class ZTRANS_LXE_FUNCTION_GROUP
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_FUNCTION_GROUP
*&quot;* do not include other source files here!!!
protected section.

  methods GET_OBJECT_TEXT
    redefinition .</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_LXE_FUNCTION_GROUP
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_LXE_FUNCTION_GROUP" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140303" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_FUNCTION_GROUP" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_FUNCTION_GROUP" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_OBJECT_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_FUNCTION_GROUP" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_lxe_type.
* Function group
  APPEND &apos;FUGR&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_object_text.
* Tipo de objeto de texto del objeto pasado.
  r_obj_text = &apos;REPT&apos;.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_true.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="LXE: Program plugin" UUID="E3A15E5C7AD014F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE">
  <publicSection>class ZTRANS_LXE_PROGRAM definition
  public
  inheriting from ZTRANS_LXE
  final
  create public .

*&quot;* public components of class ZTRANS_LXE_PROGRAM
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_PROGRAM
*&quot;* do not include other source files here!!!
protected section.

  methods GET_OBJECT_TEXT
    redefinition .</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02705
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_LXE_PROGRAM" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_PROGRAM" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_PROGRAM" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_OBJECT_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_PROGRAM" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_LXE_TYPE.
* Programas
  APPEND &apos;PROG&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_OBJECT_TEXT.
  DATA ls_ddenq TYPE ddenqs.
  DATA ld_objtyp   TYPE e071-object.
  DATA ld_pgmid    TYPE e071-pgmid.
  DATA ld_obj_name TYPE e071-obj_name.

* Se pasa los datos a una estructura para obtener el objeto de texto.
  ls_ddenq-objname = i_obj_name.
  ls_ddenq-objtype = i_object.

  PERFORM determine_lock_key IN PROGRAM SAPLSEUQ USING    space
                                        &apos;PROG&apos;
                                        ls_ddenq
                               CHANGING ld_pgmid
                                        ld_objtyp
                                        ld_obj_name.

* Tipo de objeto de texto del objeto pasado.
  r_obj_text = ld_objtyp.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_true.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_SINGLE_MESS" VERSION="1" LANGU="E" DESCRIPT="LXE: Single messages plugin" UUID="E3A15DF77E6CAAF196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE">
  <types CLSNAME="ZTRANS_LXE_SINGLE_MESS" CMPNAME="TY_MESSAGE_KEY" VERSION="1" LANGU="E" DESCRIPT="Message key" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="27 " R3RELEASE="700" TYPESRC_LENG="127 " TYPESRC="BEGIN OF ty_message_key,
        message_id type symsgid,
        message_nr type t100-msgnr,
       END OF ty_message_key
"/>
  <publicSection>class ZTRANS_LXE_SINGLE_MESS definition
  public
  inheriting from ZTRANS_LXE
  final
  create public .

*&quot;* public components of class ZTRANS_LXE_SINGLE_MESS
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods SET_CHECK_PARAMS
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_SINGLE_MESS
*&quot;* do not include other source files here!!!
protected section.

  types:
    BEGIN OF ty_message_key,
        message_id type symsgid,
        message_nr type t100-msgnr,
       END OF ty_message_key .

  methods GET_OBJECT_TEXT
    redefinition .</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02707
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_LXE_SINGLE_MESS" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_SINGLE_MESS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_SINGLE_MESS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_OBJECT_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_SINGLE_MESS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_SINGLE_MESS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="SET_CHECK_PARAMS"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_LXE_TYPE.
APPEND &apos;MESS&apos; TO r_objects.
endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_OBJECT_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_OBJECT_TEXT.
  r_obj_text = &apos;MESS&apos;.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_true.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD SET_CHECK_PARAMS.
  DATA ld_leng TYPE i.
  DATA ld_obj_name TYPE sobj_name.
  DATA ls_message_key TYPE ty_message_key.

* El nombre del mensaje requiere de un ajuste para poderlo traducir.
* En el nombre que se pasa los tres ultimos digitos es el numero de mensaje. Tengo que separarlos en dos
* para pasarlo a la estructura.
* Calculo la longitud total quitandole el espacio del numero de mensaje
  ld_leng = STRLEN( i_obj_name ) - 3.

* Hago un offset para recuperar los valores.
  ls_message_key-message_id = i_obj_name(ld_leng).
  ls_message_key-message_nr = i_obj_name+ld_leng(3).

* Finalmente muevo la estructura a una variable.
  ld_obj_name = ls_message_key.

* Llamo al método de la clase padre para que se encargue del resto.
  CALL METHOD super-&gt;set_check_params
    EXPORTING
      i_object         = i_object
      i_obj_name       = ld_obj_name
      i_olang          = i_olang
      i_tlang          = i_tlang
    EXCEPTIONS
      object_not_valid = 1
      OTHERS           = 2.
  IF sy-subrc &lt;&gt; 0.
    RAISE object_not_valid.
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_LXE_SMARTFORMS" VERSION="1" LANGU="E" DESCRIPT="LXE: Smartforms" UUID="E3A7C69D8460EDF196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDON="20140907" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_LXE" CHANGEDBY="RODIVA01">
  <publicSection>class ZTRANS_LXE_SMARTFORMS definition
  public
  inheriting from ZTRANS_LXE
  final
  create public .

*&quot;* public components of class ZTRANS_LXE_SMARTFORMS
*&quot;* do not include other source files here!!!
public section.

  methods GET_LXE_TYPE
    redefinition .
  methods LOAD_TEXT
    redefinition .
  methods SET_CHECK_PARAMS
    redefinition .
  methods HAS_PROPOSED_TEXT
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_LXE_SMARTFORMS
*&quot;* do not include other source files here!!!
protected section.

  data D_OLANG_R3 type SPRAS .
  data D_TLANG_R3 type SPRAS .
  data D_OBJTYPE type TROBJTYPE value &apos;SSF&apos;. &quot;#EC NOTEXT .
  data ET_LWRKOBJ type LWRKOBJ .</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_LXE_SMARTFORMS
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZTRANS_LXE_SMARTFORMS" CMPNAME="D_OBJTYPE" VERSION="1" LANGU="4" DESCRIPT="Object Type" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140311" CHANGEDON="00000000" ATTDECLTYP="0" ATTVALUE="&apos;SSF&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE_SMARTFORMS" CMPNAME="D_OLANG_R3" VERSION="1" LANGU="4" DESCRIPT="Source Language R3" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140311" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SPRAS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE_SMARTFORMS" CMPNAME="D_TLANG_R3" VERSION="1" LANGU="4" DESCRIPT="Target Language R3" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140311" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SPRAS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_LXE_SMARTFORMS" CMPNAME="ET_LWRKOBJ" VERSION="1" LANGU="4" DESCRIPT="Object lists for worklists" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140311" CHANGEDON="00000000" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LWRKOBJ" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZTRANS_LXE_SMARTFORMS" REFCLSNAME="ZTRANS_LXE" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140309" CHANGEDBY="RODIVA01" CHANGEDON="20140907">
   <redefinition CLSNAME="ZTRANS_LXE_SMARTFORMS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="GET_LXE_TYPE"/>
   <redefinition CLSNAME="ZTRANS_LXE_SMARTFORMS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="HAS_PROPOSED_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_SMARTFORMS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="LOAD_TEXT"/>
   <redefinition CLSNAME="ZTRANS_LXE_SMARTFORMS" REFCLSNAME="ZTRANS_LXE" VERSION="1" MTDNAME="SET_CHECK_PARAMS"/>
  </inheritance>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="GET_LXE_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_lxe_type.
  APPEND &apos;SSFO&apos; TO r_objects.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="HAS_PROPOSED_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD has_proposed_text.
  r_has = abap_false.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="LOAD_TEXT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD load_text.
  FIELD-SYMBOLS &lt;ls_tline_source&gt; TYPE LINE OF tline_tab.
  FIELD-SYMBOLS &lt;ls_tline_target&gt; TYPE LINE OF tline_tab.
  DATA lt_tline_source TYPE tline_tab.
  DATA lt_tline_target TYPE tline_tab.

  CALL FUNCTION &apos;SSFTR_GET_TEXT&apos;
    EXPORTING
      sourcelang       = d_olang_r3
      targetlang       = d_tlang_r3
    TABLES
      sourcetext       = lt_tline_source
      targettext       = lt_tline_target
    CHANGING
      tlwrkobj         = et_lwrkobj
    EXCEPTIONS
      object_not_found = 1
      OTHERS           = 2.




ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_LXE" CMPNAME="SET_CHECK_PARAMS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD set_check_params.
  DATA ls_colob TYPE lxe_colob.
  DATA ls_prefs TYPE lxe_upsets.
  DATA ld_lxe_objname TYPE lxeobjname.

* Guardo los parametros pasados a variables globales.
  d_object = i_object.
  d_obj_name = i_obj_name.
  d_olang = i_olang.
  d_tlang = i_tlang.

* Para recuperar el texto hay que pasar el idioma en R/3, por eso se realiza
* la conversion de los dos idiomas.
  CALL FUNCTION &apos;LXE_T002_CHECK_LANGUAGE&apos;
    EXPORTING
      language           = d_olang
    IMPORTING
      o_r3_lang          = d_olang_r3
    EXCEPTIONS
      language_not_in_cp = 1
      unknown            = 2
      OTHERS             = 3.

  CALL FUNCTION &apos;LXE_T002_CHECK_LANGUAGE&apos;
    EXPORTING
      language           = d_tlang
    IMPORTING
      o_r3_lang          = d_tlang_r3
    EXCEPTIONS
      language_not_in_cp = 1
      unknown            = 2
      OTHERS             = 3.

* Llamo a la funcion que me devolverá las preferencia de usuario.
* Acceso a esta funcion para saber el área de traduccion. Por regla general
* es &apos;999999&apos;.
  CALL FUNCTION &apos;LXE_SE63_TRANSLATION_PREFS_GET&apos;
    EXPORTING
      uname                   = sy-uname
    CHANGING
      preferences_worklist    = ls_prefs
    EXCEPTIONS
      no_default_preset_found = 1
      OTHERS                  = 2.

  IF sy-subrc = 0.
    ls_colob-custmnr =  ls_prefs-custmnr.
  ELSE.
    ls_colob-custmnr = &apos;999999&apos;.
  ENDIF.
  ld_lxe_objname = i_obj_name.
  CALL FUNCTION &apos;LXE_OBJ_CONVERT_OL_WLB&apos;
    EXPORTING
      in_custmnr = ls_colob-custmnr
      in_objtype = ls_colob-objtype
      in_objname = ld_lxe_objname
    IMPORTING
      objname    = ls_colob-objname.
  ls_colob-objtype = d_objtype.
  APPEND ls_colob TO it_colob.


* Relleno la estructura del objeto a traducir que se usará
* tanto para leer como para grabar.
  et_lwrkobj-targetlang = d_tlang_r3.
  et_lwrkobj-objtype = d_objtype.
  et_lwrkobj-objname = d_obj_name.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZTRANS_TOOL" VERSION="1" LANGU="E" DESCRIPT="Translation tool" UUID="E3A15EBE4EF114F196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZTRANS_TOOL" CMPNAME="TY_T_LXE_T002" VERSION="1" LANGU="E" DESCRIPT="Languages in the Translation Environment" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="48 " TYPESRC_LENG="47 " TYPESRC="ty_t_lxe_t002 TYPE STANDARD TABLE OF lxe_t002
"/>
  <types CLSNAME="ZTRANS_TOOL" CMPNAME="TY_T_LXE_T002T" VERSION="1" LANGU="E" DESCRIPT="Languages in the Translation Environment" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="50 " TYPESRC_LENG="49 " TYPESRC="ty_t_lxe_t002t TYPE STANDARD TABLE OF lxe_t002t
"/>
  <types CLSNAME="ZTRANS_TOOL" CMPNAME="TY_MNGT_TEXT" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="27 " TYPESRC_LENG="245 " TYPESRC="BEGIN OF ty_mngt_text,
           object TYPE trobjtype,
           obj_name TYPE sobj_name,
           tlang TYPE lxeisolang,
           oobject TYPE REF TO ztrans_lxe,
           data_changed TYPE sap_bool,
         END OF ty_mngt_text
"/>
  <types CLSNAME="ZTRANS_TOOL" CMPNAME="TY_T_MNGT_TEXT" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="59 " TYPESRC_LENG="112 " TYPESRC="ty_t_mngt_text TYPE SORTED TABLE OF ty_mngt_text
                   WITH NON-UNIQUE KEY object obj_name tlang
"/>
  <types CLSNAME="ZTRANS_TOOL" CMPNAME="TY_T_MAIN_FIELDS" VERSION="1" LANGU="E" DESCRIPT="IT Main fields to the data table" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="61 " TYPESRC_LENG="60 " TYPESRC="ty_t_main_fields TYPE STANDARD TABLE OF ztrans_main_fields
"/>
  <publicSection>class ZTRANS_TOOL definition
  public
  create public .

*&quot;* public components of class ZTRANS_TOOL
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .
  type-pools TRWBO .

  data D_OBJECT type TROBJTYPE read-only .
  data D_OBJ_NAME type SOBJ_NAME read-only .
  constants DC_FIELD_TXT_LANG type BSSTRING value &apos;FIELD_&apos;. &quot;#EC NOTEXT
  constants DC_FIELD_CTRL_LANG type BSSTRING value &apos;UPDKZ_&apos;. &quot;#EC NOTEXT
  constants DC_STRUC_MAIN_FIELDS type TABNAME value &apos;ZTRANS_MAIN_FIELDS&apos;. &quot;#EC NOTEXT
  constants DC_FIELD_STYLE type FIELDNAME value &apos;FIELD_STYLE&apos;. &quot;#EC NOTEXT
  constants DC_STYLE_WO_TRANS type RAW4 value &apos;0000000F&apos;. &quot;#EC NOTEXT
  constants DC_STYLE_PROP_WO_CONF type RAW4 value &apos;0000000C&apos;. &quot;#EC NOTEXT
  constants DC_STYLE_PROP_CONF type RAW4 value &apos;0000000E&apos;. &quot;#EC NOTEXT
  constants DC_STYLE_TEXT_CHANGED type RAW4 value &apos;0000000A&apos;. &quot;#EC NOTEXT

  methods CONSTRUCTOR .
  methods GET_LANGUAGES .
  methods CHECK_OBJ_2_TRANS
    importing
      !I_OBJECT type TROBJTYPE
      !I_OBJ_NAME type SOBJ_NAME
    returning
      value(R_EXIST) type SAP_BOOL .
  methods LOAD_OBJECT_TEXTS .
  methods SET_PARAMS_SELSCREEN
    importing
      !I_OLANG type LXEISOLANG
      !I_T_TLANG type LXE_TT_LXEISOLANG
      !I_TRKORR type TRKORR optional
      !I_DEPTH_REFS type I default 2 .
  methods GET_DATA
    returning
      value(R_DATA) type ref to DATA .
  methods SET_DATA
    importing
      !I_T_DATA type ref to DATA .
  methods GET_FCAT
    returning
      value(R_FCAT) type LVC_T_FCAT .
  methods SAVE_DATA
    returning
      value(R_RETURN) type BAPIRET2 .
  methods TRANSPORT_MOD_OBJ
    exporting
      value(E_RETURN) type BAPIRET2 .
  methods GET_ALLOWED_OBJECTS
    returning
      value(R_OBJECTS) type TR_OBJECT_TEXTS .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_TOOL
*&quot;* do not include other source files here!!!
protected section.

  types:
    ty_t_lxe_t002 TYPE STANDARD TABLE OF lxe_t002 .
  types:
    ty_t_lxe_t002t TYPE STANDARD TABLE OF lxe_t002t .
  types:
    BEGIN OF ty_mngt_text,
           object TYPE trobjtype,
           obj_name TYPE sobj_name,
           tlang TYPE lxeisolang,
           oobject TYPE REF TO ztrans_lxe,
           data_changed TYPE sap_bool,
         END OF ty_mngt_text .
  types:
    ty_t_mngt_text TYPE SORTED TABLE OF ty_mngt_text
                   WITH NON-UNIQUE KEY object obj_name tlang .
  types:
    ty_t_main_fields TYPE STANDARD TABLE OF ztrans_main_fields .

  data IT_LXE_T002 type TY_T_LXE_T002 .
  data IT_LXE_T002T type TY_T_LXE_T002T .
  data IT_TLANG type LXE_TT_LXEISOLANG .
  data D_OLANG type LXEISOLANG .
  data GO_IT_DATA type ref to DATA .
  data GO_WA_DATA type ref to DATA .
  data IT_FCAT type LVC_T_FCAT .
  data IT_MNGT_TEXT type TY_T_MNGT_TEXT .
  data D_TRKORR type E070-TRKORR .
  data IT_COMPONENTS type TY_T_MAIN_FIELDS .
  class ZTRANS_CMP definition load .
  data IT_OBJECT_LIST type ZTRANS_CMP=&gt;TY_T_OBJECT_LIST .
  class ZTRANS_LXE definition load .
  data IT_LXE_LIST type ZTRANS_LXE=&gt;TY_T_LXE_LIST .
  data D_DEPTH_REFS type I .

  methods UPDATE_TEXT_OBJECT .
  methods COPY_1_OF_READ_PROCESS_TEXTS .
  methods READ_PROCESS_TEXTS .
  methods CHANGE_TEXT_FCAT
    importing
      !I_TEXT type ANY
    changing
      !C_FCAT type LVC_S_FCAT .
  methods GET_COMPONENTS
    exporting
      value(E_COMPONENTS) type TY_T_MAIN_FIELDS .
  methods CREATE_IT_FCAT .
  methods GET_NAME_FIELD_CTRL
    importing
      !I_LANGUAGE type LXEISOLANG
    returning
      value(R_FIELDNAME) type FIELDNAME .
  methods GET_NAME_FIELD_TEXT
    importing
      !I_LANGUAGE type LXEISOLANG
    returning
      value(R_FIELDNAME) type FIELDNAME .
  class-methods FILL_RETURN
    importing
      !I_TYPE type ANY
      !I_NUMBER type ANY
      !I_MESSAGE_V1 type ANY optional
      !I_MESSAGE_V2 type ANY optional
      !I_MESSAGE_V3 type ANY optional
      !I_MESSAGE_V4 type ANY optional
      !I_ID type ANY optional
    returning
      value(R_RETURN) type BAPIRET2 .
  methods GET_REF_TEXT_OBJECT
    importing
      !I_OBJECT type TROBJTYPE
      !I_OBJ_NAME type SOBJ_NAME
      !I_TLANG type LXEISOLANG
    exporting
      !E_OBJECT type ref to ZTRANS_LXE .
  methods PROPOSAL_TEXT
    importing
      !I_TLANG type LXEISOLANG
      !IS_TEXTS type ZTRANS_TEXTS
      !IO_OBJECT_TEXT type ref to ZTRANS_LXE
    changing
      !CS_WA type ANY .</protectedSection>
  <privateSection>*&quot;* private components of class ZTRANS_TOOL
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZTRANS_TOOL" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <typeUsage CLSNAME="ZTRANS_TOOL" TYPEGROUP="TRWBO" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>TRWBO</forwardDeclaration>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_FIELD_CTRL_LANG" VERSION="1" LANGU="4" DESCRIPT="Name of field of control text" EXPOSURE="2" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;UPDKZ_&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BSSTRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_FIELD_STYLE" VERSION="1" LANGU="4" DESCRIPT="Name of field for styles" EXPOSURE="2" STATE="1" EDITORDER="6 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;FIELD_STYLE&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FIELDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_FIELD_TXT_LANG" VERSION="1" LANGU="4" DESCRIPT="Name of field with the text" EXPOSURE="2" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;FIELD_&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BSSTRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_STRUC_MAIN_FIELDS" VERSION="1" LANGU="4" DESCRIPT="Structure with main fields" EXPOSURE="2" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140301" ATTDECLTYP="2" ATTVALUE="&apos;ZTRANS_MAIN_FIELDS&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TABNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_STYLE_PROP_CONF" VERSION="1" LANGU="4" DESCRIPT="Proposal confirmed" EXPOSURE="2" STATE="1" EDITORDER="9 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;0000000E&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="RAW4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_STYLE_PROP_WO_CONF" VERSION="1" LANGU="4" DESCRIPT="Proposal w/o confirmed" EXPOSURE="2" STATE="1" EDITORDER="8 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;0000000C&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="RAW4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_STYLE_TEXT_CHANGED" VERSION="1" LANGU="4" DESCRIPT="Text changed in ALV" EXPOSURE="2" STATE="1" EDITORDER="10 " AUTHOR="RODIVA01" CREATEDON="20140325" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;0000000A&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="RAW4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="DC_STYLE_WO_TRANS" VERSION="1" LANGU="4" DESCRIPT="Text w/o translation" EXPOSURE="2" STATE="1" EDITORDER="7 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;0000000F&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="RAW4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="D_DEPTH_REFS" VERSION="1" LANGU="4" DESCRIPT="Depth level references" EXPOSURE="1" STATE="1" EDITORDER="13 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="D_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="D_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" EXPOSURE="2" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOBJ_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="D_OLANG" VERSION="1" LANGU="4" DESCRIPT="ISO Language ID" EXPOSURE="1" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXEISOLANG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="D_TRKORR" VERSION="1" LANGU="4" DESCRIPT="Request/Task" EXPOSURE="1" STATE="1" EDITORDER="9 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="E070-TRKORR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="GO_IT_DATA" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="GO_WA_DATA" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="6 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_COMPONENTS" VERSION="1" LANGU="4" DESCRIPT="IT Main fields to the data table" EXPOSURE="1" STATE="1" EDITORDER="10 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_MAIN_FIELDS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_FCAT" VERSION="1" LANGU="4" DESCRIPT="Field Catalog for List Viewer Control" EXPOSURE="1" STATE="1" EDITORDER="7 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LVC_T_FCAT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_LXE_LIST" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="12 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRANS_LXE=&gt;TY_T_LXE_LIST" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_LXE_T002" VERSION="1" LANGU="4" DESCRIPT="Languages in the Translation Environment" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_LXE_T002" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_LXE_T002T" VERSION="1" LANGU="4" DESCRIPT="Languages in the Translation Environment" EXPOSURE="1" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_LXE_T002T" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_MNGT_TEXT" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="8 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_MNGT_TEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_OBJECT_LIST" VERSION="1" LANGU="4" EXPOSURE="1" STATE="1" EDITORDER="11 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRANS_CMP=&gt;TY_T_OBJECT_LIST" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZTRANS_TOOL" CMPNAME="IT_TLANG" VERSION="1" LANGU="4" DESCRIPT="Languages" EXPOSURE="1" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="LXE_TT_LXEISOLANG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="CHANGE_TEXT_FCAT" VERSION="1" LANGU="4" DESCRIPT="Change text in the fieldcatalog" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="CHANGE_TEXT_FCAT" SCONAME="I_TEXT" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="CHANGE_TEXT_FCAT" SCONAME="C_FCAT" VERSION="1" LANGU="4" DESCRIPT="ALV control: Field catalog" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_S_FCAT"/>
   <source>METHOD CHANGE_TEXT_FCAT.
  c_fcat-scrtext_l = i_text.
  c_fcat-scrtext_s = i_text.
  c_fcat-scrtext_m = i_text.
  c_fcat-reptext = i_text.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="CHECK_OBJ_2_TRANS" VERSION="1" LANGU="4" DESCRIPT="Check  object to translate" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="CHECK_OBJ_2_TRANS" SCONAME="I_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="CHECK_OBJ_2_TRANS" SCONAME="I_OBJ_NAME" VERSION="1" LANGU="4" DESCRIPT="Object Name in Object Directory" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOBJ_NAME"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="CHECK_OBJ_2_TRANS" SCONAME="R_EXIST" VERSION="1" LANGU="4" DESCRIPT="Boolean Variable (X=True, Space=False)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SAP_BOOL"/>
   <source>METHOD CHECK_OBJ_2_TRANS.
  FIELD-SYMBOLS &lt;ls_object_list&gt; LIKE LINE OF it_object_list.

* Aprovecha para guardar el objeto y el nombre del mismo. Se utilizará
* en otros puntos del programa
  d_object = i_object.
  d_obj_name = i_obj_name.

  READ TABLE it_object_list ASSIGNING &lt;ls_object_list&gt; WITH KEY object = i_object.
  IF sy-subrc = 0.
    r_exist = &lt;ls_object_list&gt;-ref_class-&gt;check_object_exists( i_pgmid = &lt;ls_object_list&gt;-pgmid
                                                               i_object   = i_object
                                                               i_obj_name = i_obj_name ).
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="4" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="2" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD constructor.

* Carga de los idioma del entorno de traduccion
  get_languages( ).

* Se obtiene por separado los objetos que pueden ser traducidos y las clases que permiten
* traducir dichos objetos.
* El motivo de hacerlo separado es que muchos objetos se traducen de la misma manera: programas, funciones,
* clases, etc.. Por eso de la separacion.

* Obtengo los objetos que: 1) pueden ser traducidos 2) podemos obtener componentes.
  ztrans_cmp=&gt;get_objectlist( IMPORTING e_object_list = it_object_list ).

* Obtengo los objetos cuyo proceso de traduccion esta implementado.
  ztrans_lxe=&gt;get_lxelist( IMPORTING e_lxe_list = it_lxe_list  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="COPY_1_OF_READ_PROCESS_TEXTS" VERSION="1" LANGU="E" DESCRIPT="Read and processing texts" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD copy_1_of_read_process_texts.
  FIELD-SYMBOLS &lt;tbl&gt; TYPE table.
  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field_style&gt; TYPE ANY TABLE.
  FIELD-SYMBOLS &lt;ls_tlang&gt; LIKE LINE OF it_tlang.
  FIELD-SYMBOLS &lt;ls_texts&gt; TYPE ztrans_texts.
  FIELD-SYMBOLS &lt;ls_lxe_list&gt; LIKE LINE OF it_lxe_list.
  DATA ls_main_fields TYPE LINE OF ty_t_main_fields.
  DATA lt_main_fields TYPE ty_t_main_fields.
  DATA lo_data TYPE REF TO data.
  DATA ls_mngt_text LIKE LINE OF it_mngt_text.
  DATA ld_tabix TYPE sytabix.
  DATA lt_texts TYPE STANDARD TABLE OF ztrans_texts.
  DATA ld_primer_source TYPE sap_bool.
  DATA ld_field_text TYPE fieldname.
  DATA ls_field_style TYPE LINE OF lvc_t_styl.
  DATA ld_tabix_mngt TYPE sytabix.
  DATA ld_text_object TYPE REF TO ztrans_lxe.

  ASSIGN go_it_data-&gt;* TO &lt;tbl&gt;.

  CLEAR &lt;tbl&gt;.

  LOOP AT it_components INTO ls_main_fields.

* En el primer texto informaré tanto el idioma de origen como el destino.
* a partir del segundo idioma de destino solo leerá el de destino.
    ld_primer_source = abap_true.

* Se recorre la tabla de idioma a traducir.
    LOOP AT it_tlang ASSIGNING &lt;ls_tlang&gt;.
      CLEAR: ls_mngt_text, lt_texts.

* Se recupera el objeto de texto para obtener las traducciones
      CALL METHOD get_ref_text_object
        EXPORTING
          i_object   = ls_main_fields-object
          i_obj_name = ls_main_fields-obj_name
          i_tlang    = &lt;ls_tlang&gt;
        IMPORTING
          e_object   = ld_text_object.


      IF ld_text_object IS BOUND.

* Miro si el objeto ya ha sido instancio previamente. Si no es así, se crea.
        READ TABLE it_mngt_text INTO ls_mngt_text
                                WITH TABLE KEY object = ls_main_fields-object
                                               obj_name = ls_main_fields-obj_name
                                               tlang = &lt;ls_tlang&gt;.
        IF sy-subrc NE 0.
* Pongo la posicion cero para que se inserte el registro.
          ld_tabix_mngt = 0.
* Se pasa los datos a la tabla que contendrá el objetos de textos en cada
* idioma para cada objeto.
          ls_mngt_text-tlang = &lt;ls_tlang&gt;.
          ls_mngt_text-object = ls_main_fields-object.
          ls_mngt_text-obj_name = ls_main_fields-obj_name.

* Recupero la clase que servirá para traducir el objeto.
          READ TABLE it_lxe_list ASSIGNING &lt;ls_lxe_list&gt; WITH KEY object = ls_main_fields-object.
          IF sy-subrc = 0.
* Instancio el objeto que hará la traduccion
            CREATE OBJECT ls_mngt_text-oobject TYPE (&lt;ls_lxe_list&gt;-class).

* Valido que el objeto sea valido.
            CALL METHOD ls_mngt_text-oobject-&gt;set_check_params
              EXPORTING
                i_object         = ls_main_fields-object
                i_obj_name       = ls_main_fields-obj_name
                i_olang          = d_olang
                i_tlang          = &lt;ls_tlang&gt;
              EXCEPTIONS
                object_not_valid = 1
                OTHERS           = 2.
            IF sy-subrc = 0.
* Leo los datos
              ls_mngt_text-oobject-&gt;load_text( ).

* Recupero los textos para pasarlos a la tabla de datos
              ls_mngt_text-oobject-&gt;get_texts( IMPORTING e_texts = lt_texts ).
            ENDIF.
          ENDIF.
        ELSE.
* Me guardo la posición para despues actualizarla.
          ld_tabix_mngt = sy-tabix.
* Vuelvo a cargar los datos
          ls_mngt_text-oobject-&gt;load_text( ).
* Recupero los textos.
          ls_mngt_text-oobject-&gt;get_texts( IMPORTING e_texts = lt_texts ).
        ENDIF.

* Solo se tienen en cuanta los objetos con textos.
        IF lt_texts IS NOT INITIAL.

* Recorro la tabla de textos para pasarla a la de datos.
          LOOP AT lt_texts ASSIGNING &lt;ls_texts&gt;.
            ls_main_fields-id_text = &lt;ls_texts&gt;-textkey. &quot; Id del texto
            ls_main_fields-objtype = &lt;ls_texts&gt;-objtype. &quot; Tipo de objeto

            IF ld_primer_source = abap_true.
              ls_main_fields-txt_olang = &lt;ls_texts&gt;-s_text.
            ENDIF.

* Leo si el para el objeto e id de texto esta en la tabla que guarda de manera temporal lo mismo(campos principales) que la
* tabla global dinámica. Esta tabla permite evitar duplicados o más cuando hay varios idiomas a traducir para un mismo objeto.
            READ TABLE lt_main_fields TRANSPORTING NO FIELDS WITH KEY object = ls_main_fields-object
                                                                      obj_name = ls_main_fields-obj_name
                                                                      id_text = ls_main_fields-id_text
                                                                      objtype = ls_main_fields-objtype.
            IF sy-subrc = 0.
* Me guardo la posicion donde se ha encontrado.
              ld_tabix = sy-tabix.
* Los registros de la tabla loca y temporal siempre coinciden porque se añaden los mismos datos.
              READ TABLE &lt;tbl&gt; ASSIGNING &lt;wa&gt; INDEX ld_tabix.
            ELSE.
              CLEAR ld_tabix.
* Reasigno la cabecera para limpiar valores previos.
              ASSIGN go_wa_data-&gt;* TO &lt;wa&gt;.
              APPEND ls_main_fields TO lt_main_fields.
* Paso los datos comunes a la cabecera de la tabla de datos
              MOVE-CORRESPONDING ls_main_fields TO &lt;wa&gt;.
            ENDIF.

* Construyo el campo donde se pondra el texto destino
            ld_field_text = get_name_field_text( &lt;ls_tlang&gt; ).
            ASSIGN COMPONENT ld_field_text OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
            IF sy-subrc = 0.
              &lt;field&gt; = &lt;ls_texts&gt;-t_text.
              IF &lt;field&gt; IS INITIAL.
* Recupero la mejor propuesta para el campo
                CALL METHOD ls_mngt_text-oobject-&gt;get_best_text_proposal
                  EXPORTING
                    i_textkey   = &lt;ls_texts&gt;-textkey
                    i_objtype   = &lt;ls_texts&gt;-objtype
                  IMPORTING
                    e_best_text = &lt;field&gt;.
              ENDIF.

* Determino el estilo según el valor del campo
              ASSIGN COMPONENT dc_field_style OF STRUCTURE &lt;wa&gt; TO &lt;field_style&gt;.
              IF sy-subrc = 0.
                ls_field_style-fieldname = ld_field_text.
* Si no hay texto ni por propuesta ni por origen se pone el color de no hay traduccion
                IF &lt;field&gt; IS INITIAL.
                  ls_field_style-style = dc_style_wo_trans.
* Si hay texto por la propuesta pero el original no lo tenia, se pone el texto de pdte de confirmacion.
                ELSEIF &lt;ls_texts&gt;-t_text IS INITIAL.
                  ls_field_style-style = dc_style_prop_wo_conf.
                ELSE.
* Si el texto esta informado compruebo si el texto esta dentro de las propuestas
* para el texto. Según el resultado el color de la celda varia.
                  IF ls_mngt_text-oobject-&gt;is_text_in_proposal( i_text = &lt;field&gt;
                                                                i_textkey = &lt;ls_texts&gt;-textkey
                                                                i_objtype = &lt;ls_texts&gt;-objtype ) = abap_true.
                    ls_field_style-style = dc_style_prop_conf.
                  ELSE.
                    ls_field_style-style = dc_style_prop_wo_conf.
                  ENDIF.
                ENDIF.
                INSERT ls_field_style INTO TABLE &lt;field_style&gt;.
                CLEAR ls_field_style.
              ENDIF.
            ENDIF.

* Si el objeto e id de texto no esta en la tabla temporal, muevo los campos principales
* a la cabecera y añado los datos.
            IF ld_tabix IS INITIAL.
              APPEND &lt;wa&gt; TO &lt;tbl&gt;.
              CLEAR &lt;wa&gt;.
            ENDIF.

          ENDLOOP.

* Segun el valor de la variable ld_tabix_mngt se sabe si hay que insertar o modificar.
          IF ld_tabix_mngt IS INITIAL.
            INSERT ls_mngt_text INTO TABLE it_mngt_text.
          ELSE.
            MODIFY it_mngt_text FROM ls_mngt_text INDEX ld_tabix_mngt.
          ENDIF.

* Marco para que el texto de origen no se vuelva a pasar porque ya se ha hecho con el primer idioma.
          ld_primer_source = abap_false.

        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="CREATE_IT_FCAT" VERSION="1" LANGU="4" DESCRIPT="Create internal table and fieldcat" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD create_it_fcat.
  FIELD-SYMBOLS &lt;ls_dlang&gt; LIKE LINE OF it_tlang.
  FIELD-SYMBOLS &lt;ls_fcat&gt; TYPE LINE OF lvc_t_fcat.
  FIELD-SYMBOLS &lt;ls_lxe_t002t&gt; LIKE LINE OF it_lxe_t002t.
  DATA ls_fcat TYPE LINE OF lvc_t_fcat.
  DATA lo_main_fields TYPE REF TO data.
  DATA lt_fcat_aux TYPE lvc_t_fcat.
  DATA ld_col_pos TYPE i VALUE 1.

  FREE: go_it_data, go_wa_data.

* Se crea el objeto temporal con los campos base.
  CALL METHOD zzc_ca02401=&gt;create_wa_from_struc
    EXPORTING
      i_struc    = dc_struc_main_fields
    IMPORTING
      e_workarea = lo_main_fields.

* Recupero el catalogo de la tabla de campos
  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name       = dc_struc_main_fields
      i_bypassing_buffer     = &apos;X&apos;
    CHANGING
      ct_fieldcat            = it_fcat[]
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

* Se ajusta el catalogo de campos principal
  LOOP AT it_fcat ASSIGNING &lt;ls_fcat&gt;.
    CASE &lt;ls_fcat&gt;-fieldname.
      WHEN &apos;TXT_OLANG&apos;. &quot; Texto origen
* Se pone el texto del idioma de origen
        READ TABLE it_lxe_t002t ASSIGNING &lt;ls_lxe_t002t&gt; WITH KEY language = d_olang.
        IF sy-subrc = 0.
          CALL METHOD change_text_fcat( EXPORTING i_text = &lt;ls_lxe_t002t&gt;-sptxt
                                        CHANGING c_fcat = &lt;ls_fcat&gt; ).
        ENDIF.
        &lt;ls_fcat&gt;-col_opt = abap_true.
    ENDCASE.

* Los campos principales son fijos para que se pueden ver en todo momento.
    &lt;ls_fcat&gt;-fix_column = abap_true.
    ADD 1 TO ld_col_pos.
  ENDLOOP.

* Construyo los campos que se añadirán a la tabla base para crear la principal
* Por cada idioma se ponen dos campos: 1) campo con el texto 2) indicador que se ha modificado el campo
  LOOP AT it_tlang ASSIGNING &lt;ls_dlang&gt;.

* Campo con el texto
    CLEAR ls_fcat.
    ls_fcat-fieldname = get_name_field_text( &lt;ls_dlang&gt; ).
*    ls_fcat-rollname = &apos;LXEUNITLIN&apos;.
    ls_fcat-inttype = &apos;C&apos;.
    ls_fcat-intlen = &apos;255&apos;.
    ls_fcat-lowercase = abap_true.
    ls_fcat-edit = abap_true.
    ls_fcat-col_opt = abap_true.
    ls_fcat-col_pos = ld_col_pos.

* Texto del campo
    READ TABLE it_lxe_t002t ASSIGNING &lt;ls_lxe_t002t&gt; WITH KEY language = &lt;ls_dlang&gt;.
    IF sy-subrc = 0.
      CALL METHOD change_text_fcat( EXPORTING i_text = &lt;ls_lxe_t002t&gt;-sptxt
                                 CHANGING c_fcat = ls_fcat ).
    ELSE.
      CALL METHOD change_text_fcat( EXPORTING i_text = &lt;ls_dlang&gt;
                                 CHANGING c_fcat = ls_fcat ).
    ENDIF.
    APPEND ls_fcat TO lt_fcat_aux.
    ADD 1 TO ld_col_pos.

* Campo de control
    CLEAR ls_fcat.
    CONCATENATE dc_field_ctrl_lang &lt;ls_dlang&gt; INTO ls_fcat-fieldname.
    TRANSLATE ls_fcat-fieldname TO UPPER CASE.
    ls_fcat-rollname = &apos;SAP_BOOL&apos;.
    ls_fcat-tech = abap_true.
    ls_fcat-col_pos = ld_col_pos.
    APPEND ls_fcat TO lt_fcat_aux.
    ADD 1 TO ld_col_pos.
  ENDLOOP.

* Se añaden los campos de idioma al catalogo de campos principal
  APPEND LINES OF lt_fcat_aux TO it_fcat.

* Se crea la tabla interna en base a los campos principales + los de idioma
  CALL METHOD zzc_ca02401=&gt;create_it_fields_base_ref
    EXPORTING
      i_base_fields = lo_main_fields
      i_new_fields  = lt_fcat_aux
    IMPORTING
      e_table       = go_it_data
      e_wa          = go_wa_data.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" VERSION="1" LANGU="4" DESCRIPT="Fill structure BAPIRET2 or RETURN" EXPOSURE="1" STATE="1" EDITORDER="9 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_TYPE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_NUMBER" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_MESSAGE_V1" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_MESSAGE_V2" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_MESSAGE_V3" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_MESSAGE_V4" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="I_ID" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="FILL_RETURN" SCONAME="R_RETURN" VERSION="1" LANGU="4" DESCRIPT="Return Parameter" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="BAPIRET2"/>
   <source>method FILL_RETURN.

  CLEAR r_return.

  r_return-type = i_type.

* Se no se pasa una clase de mensaje se pone la generica de la aplicación.
  IF i_id IS NOT SUPPLIED.
    r_return-id = &apos;ZTRANS_TOOL&apos;.
  ELSE.
    r_return-id = i_id.
  ENDIF.
  r_return-number = i_number.
  r_return-message_v1 = i_message_v1.
  r_return-message_v2 = i_message_v2.
  r_return-message_v3 = i_message_v3.
  r_return-message_v4 = i_message_v4.


  CALL FUNCTION &apos;BAPI_MESSAGE_GETDETAIL&apos;
    EXPORTING
      id         = r_return-id
      number     = r_return-number
      language   = sy-langu
      textformat = &apos;ASC&apos;
      message_v1 = r_return-message_v1
      message_v2 = r_return-message_v2
      message_v3 = r_return-message_v3
      message_v4 = r_return-message_v4
    IMPORTING
      message    = r_return-message.

endmethod.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_ALLOWED_OBJECTS" VERSION="1" LANGU="4" DESCRIPT="Get allowed objects" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_ALLOWED_OBJECTS" SCONAME="R_OBJECTS" VERSION="1" LANGU="4" DESCRIPT="CTS: Object Types with Description" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TR_OBJECT_TEXTS"/>
   <source>METHOD GET_ALLOWED_OBJECTS.
  FIELD-SYMBOLS &lt;ls_object_list&gt; LIKE LINE OF it_object_list.
  DATA ls_objects TYPE LINE OF tr_object_texts.

  CLEAR r_objects.
  LOOP AT it_object_list ASSIGNING &lt;ls_object_list&gt;.
    MOVE-CORRESPONDING &lt;ls_object_list&gt; TO ls_objects.
    APPEND ls_objects TO r_objects.
    CLEAR ls_objects.
  ENDLOOP.

  SORT r_objects BY pgmid object.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_COMPONENTS" VERSION="1" LANGU="4" DESCRIPT="Get components of object" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_COMPONENTS" SCONAME="E_COMPONENTS" VERSION="1" LANGU="4" DESCRIPT="IT Main fields to the data table" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_T_MAIN_FIELDS"/>
   <source>METHOD GET_COMPONENTS.
  FIELD-SYMBOLS &lt;ls_components&gt; TYPE LINE OF ztrans_cmp=&gt;ty_t_components.
  FIELD-SYMBOLS &lt;ls_object_list&gt; LIKE LINE OF it_object_list.
  DATA ls_main_fields TYPE LINE OF ty_t_main_fields.
  DATA lt_components TYPE ztrans_cmp=&gt;ty_t_components.


  READ TABLE it_object_list ASSIGNING &lt;ls_object_list&gt; WITH KEY object = d_object.
  IF sy-subrc = 0.

* Paso los parámetros para condicionar la búsqueda.
    &lt;ls_object_list&gt;-ref_class-&gt;set_params( EXPORTING i_depth_refs = d_depth_refs ).

* Obtengo el componentes del objeto a traducir.
    &lt;ls_object_list&gt;-ref_class-&gt;get_components( IMPORTING e_components = lt_components ).

* Paso los components al parámetro de salida
    LOOP AT lt_components ASSIGNING &lt;ls_components&gt;.
      MOVE-CORRESPONDING &lt;ls_components&gt; TO ls_main_fields.
      APPEND ls_main_fields TO e_components.
    ENDLOOP.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_DATA" VERSION="1" LANGU="4" DESCRIPT="Get data" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_DATA" SCONAME="R_DATA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD GET_DATA.
  r_data = go_it_data.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_FCAT" VERSION="1" LANGU="4" DESCRIPT="Get fieldcatalog" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_FCAT" SCONAME="R_FCAT" VERSION="1" LANGU="4" DESCRIPT="Field Catalog for List Viewer Control" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
   <source>METHOD GET_FCAT.
  r_fcat = it_fcat.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_LANGUAGES" VERSION="1" LANGU="4" DESCRIPT="Get languages in the translatation environment" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140902" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_LANGUAGES.

  CALL FUNCTION &apos;LXE_T002_GET_LANGUAGES&apos;
    EXPORTING
      r3_lang_only = abap_true
    TABLES
      lt_lang      = it_lxe_t002[]
      lt_langt     = it_lxe_t002t[].

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_CTRL" VERSION="1" LANGU="4" DESCRIPT="Get name field control" EXPOSURE="1" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_CTRL" SCONAME="I_LANGUAGE" VERSION="1" LANGU="4" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_CTRL" SCONAME="R_FIELDNAME" VERSION="1" LANGU="4" DESCRIPT="Field Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FIELDNAME"/>
   <source>METHOD GET_NAME_FIELD_CTRL.
  CONCATENATE dc_field_ctrl_lang i_language INTO r_fieldname.
  TRANSLATE r_fieldname TO UPPER CASE.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_TEXT" VERSION="1" LANGU="4" DESCRIPT="Get name field text" EXPOSURE="1" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_TEXT" SCONAME="I_LANGUAGE" VERSION="1" LANGU="4" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_NAME_FIELD_TEXT" SCONAME="R_FIELDNAME" VERSION="1" LANGU="4" DESCRIPT="Field Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FIELDNAME"/>
   <source>METHOD GET_NAME_FIELD_TEXT.
  CONCATENATE dc_field_txt_lang i_language INTO r_fieldname.
  TRANSLATE r_fieldname TO UPPER CASE.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="GET_REF_TEXT_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Get the instance of text object" EXPOSURE="1" STATE="1" EDITORDER="10 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_REF_TEXT_OBJECT" SCONAME="I_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Object Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TROBJTYPE"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_REF_TEXT_OBJECT" SCONAME="I_OBJ_NAME" VERSION="1" LANGU="E" DESCRIPT="Object Name in Object Directory" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOBJ_NAME"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_REF_TEXT_OBJECT" SCONAME="I_TLANG" VERSION="1" LANGU="E" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDBY="RODIVA01" CHANGEDON="20140907" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="GET_REF_TEXT_OBJECT" SCONAME="E_OBJECT" VERSION="1" LANGU="E" DESCRIPT="LXE" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDBY="RODIVA01" CHANGEDON="20140907" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="ZTRANS_LXE"/>
   <source>METHOD get_ref_text_object.
  FIELD-SYMBOLS &lt;ls_mngt_text&gt; LIKE LINE OF it_mngt_text.
  FIELD-SYMBOLS &lt;ls_lxe_list&gt; LIKE LINE OF it_lxe_list.
  DATA ls_mngt_text LIKE LINE OF it_mngt_text.

* Miro si el objeto ya ha sido instancio previamente. Si no es así, se crea.
  READ TABLE it_mngt_text ASSIGNING &lt;ls_mngt_text&gt;
                          WITH TABLE KEY object = i_object
                                         obj_name = i_obj_name
                                         tlang = i_tlang.
  IF sy-subrc NE 0.
* Se pasa los datos a la tabla que contendrá el objetos de textos en cada
* idioma para cada objeto.
    ls_mngt_text-tlang = i_tlang.
    ls_mngt_text-object = i_object.
    ls_mngt_text-obj_name = i_obj_name.

* Recupero la clase que servirá para traducir el objeto.
    READ TABLE it_lxe_list ASSIGNING &lt;ls_lxe_list&gt; WITH KEY object = i_object.
    IF sy-subrc = 0.
* Instancio el objeto que hará la traduccion
      CREATE OBJECT ls_mngt_text-oobject TYPE (&lt;ls_lxe_list&gt;-class).

* Valido que el objeto sea valido.
      CALL METHOD ls_mngt_text-oobject-&gt;set_check_params
        EXPORTING
          i_object         = i_object
          i_obj_name       = i_obj_name
          i_olang          = d_olang
          i_tlang          = i_tlang
        EXCEPTIONS
          object_not_valid = 1
          OTHERS           = 2.
      IF sy-subrc = 0.
* Se añade el nuevo registro
        INSERT ls_mngt_text INTO TABLE it_mngt_text.

* Y se devuelve el objeto.
        e_object = ls_mngt_text-oobject.
      ENDIF.
    ENDIF.
  ELSE.
    e_object = &lt;ls_mngt_text&gt;-oobject.
  ENDIF.

* Si el puntero esta asignado devuelvo el objeto de textos al parámetro de salida.
* Esto que permite:
* 1) Los datos del objeto se actualizarán solo debido a que devuelvo
* una referencia a memoria que apunta al registro de la tabla donde esta que también
* es un puntero.
* 2) Simplifica el codigo que llama a dicho método. Ya que no hay porque preocuparse
* de actualizar el registro en it_mngt_text
  IF &lt;ls_mngt_text&gt; IS ASSIGNED.

  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="LOAD_OBJECT_TEXTS" VERSION="1" LANGU="4" DESCRIPT="Load text of object" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD LOAD_OBJECT_TEXTS.
  CLEAR it_components.

* Se crea la tabla interna en base al catalogo de campos y textos a traduccion
  create_it_fcat( ).

* Componentes del objeto.
  get_components( IMPORTING e_components = it_components ).

* Lectura y proceso de los textos
  read_process_texts( ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="PROPOSAL_TEXT" VERSION="1" LANGU="E" DESCRIPT="Fill the data with the values of proposed text" EXPOSURE="1" STATE="1" EDITORDER="11 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="PROPOSAL_TEXT" SCONAME="I_TLANG" VERSION="1" LANGU="E" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="PROPOSAL_TEXT" SCONAME="IS_TEXTS" VERSION="1" LANGU="E" DESCRIPT="Texts pairs" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTRANS_TEXTS"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="PROPOSAL_TEXT" SCONAME="IO_OBJECT_TEXT" VERSION="1" LANGU="E" DESCRIPT="LXE" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZTRANS_LXE"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="PROPOSAL_TEXT" SCONAME="CS_WA" VERSION="1" LANGU="E" DESCRIPT="Workarea IT with the data" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140907" CHANGEDBY="RODIVA01" CHANGEDON="20140907" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>METHOD proposal_text.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field_style&gt; TYPE ANY TABLE.
  DATA ld_field_text TYPE fieldname.
  DATA ls_field_style TYPE LINE OF lvc_t_styl.

  ld_field_text = get_name_field_text( i_tlang ).
  ASSIGN COMPONENT ld_field_text OF STRUCTURE cs_wa TO &lt;field&gt;.
  IF sy-subrc = 0.

    IF &lt;field&gt; IS INITIAL.
* Recupero la mejor propuesta para el campo
      CALL METHOD io_object_text-&gt;get_best_text_proposal
        EXPORTING
          i_textkey   = is_texts-textkey
          i_objtype   = is_texts-objtype
        IMPORTING
          e_best_text = &lt;field&gt;.
    ENDIF.

* Determino el estilo según el valor del campo
    ASSIGN COMPONENT dc_field_style OF STRUCTURE cs_wa TO &lt;field_style&gt;.
    IF sy-subrc = 0.
      ls_field_style-fieldname = ld_field_text.
* Si no hay texto ni por propuesta ni por origen se pone el color de no hay traduccion
      IF &lt;field&gt; IS INITIAL.
        ls_field_style-style = dc_style_wo_trans.
* Si hay texto por la propuesta pero el original no lo tenia, se pone el texto de pdte de confirmacion.
      ELSEIF is_texts-t_text IS INITIAL.
        ls_field_style-style = dc_style_prop_wo_conf.
      ELSE.
* Si el texto esta informado compruebo si el texto esta dentro de las propuestas
* para el texto. Según el resultado el color de la celda varia.
        IF io_object_text-&gt;is_text_in_proposal( i_text = &lt;field&gt;
                                                      i_textkey = is_texts-textkey
                                                      i_objtype = is_texts-objtype ) = abap_true.
          ls_field_style-style = dc_style_prop_conf.
        ELSE.
          ls_field_style-style = dc_style_prop_wo_conf.
        ENDIF.
      ENDIF.
      INSERT ls_field_style INTO TABLE &lt;field_style&gt;.
      CLEAR ls_field_style.
    ENDIF.
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="READ_PROCESS_TEXTS" VERSION="1" LANGU="4" DESCRIPT="Read and processing texts" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140907" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD read_process_texts.
  FIELD-SYMBOLS &lt;tbl&gt; TYPE table.
  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;ls_tlang&gt; LIKE LINE OF it_tlang.
  FIELD-SYMBOLS &lt;ls_texts&gt; TYPE ztrans_texts.
  DATA ls_main_fields TYPE LINE OF ty_t_main_fields.
  DATA lt_main_fields TYPE ty_t_main_fields.
  DATA lo_data TYPE REF TO data.
  DATA ld_tabix TYPE sytabix.
  DATA lt_texts TYPE STANDARD TABLE OF ztrans_texts.
  DATA ld_primer_source TYPE sap_bool.
  DATA ld_field_text TYPE fieldname.
  DATA ld_text_object TYPE REF TO ztrans_lxe.

  ASSIGN go_it_data-&gt;* TO &lt;tbl&gt;.

  CLEAR &lt;tbl&gt;.

  LOOP AT it_components INTO ls_main_fields.

* En el primer texto informaré tanto el idioma de origen como el destino.
* a partir del segundo idioma de destino solo leerá el de destino.
    ld_primer_source = abap_true.

* Se recorre la tabla de idioma a traducir.
    LOOP AT it_tlang ASSIGNING &lt;ls_tlang&gt;.
      CLEAR: lt_texts.

* Se recupera el objeto de texto para obtener las traducciones
      CALL METHOD get_ref_text_object
        EXPORTING
          i_object   = ls_main_fields-object
          i_obj_name = ls_main_fields-obj_name
          i_tlang    = &lt;ls_tlang&gt;
        IMPORTING
          e_object   = ld_text_object.

      IF ld_text_object IS BOUND.

* Carga de textos y recuperacion de los textos
        ld_text_object-&gt;load_text( ).
        ld_text_object-&gt;get_texts( IMPORTING e_texts = lt_texts ).

* Solo se tienen en cuanta los objetos con textos.
        IF lt_texts IS NOT INITIAL.

* Recorro la tabla de textos para pasarla a la de datos.
          LOOP AT lt_texts ASSIGNING &lt;ls_texts&gt;.
            ls_main_fields-id_text = &lt;ls_texts&gt;-textkey. &quot; Id del texto
            ls_main_fields-objtype = &lt;ls_texts&gt;-objtype. &quot; Tipo de objeto

            IF ld_primer_source = abap_true.
              ls_main_fields-txt_olang = &lt;ls_texts&gt;-s_text.
            ENDIF.

* Leo si el para el objeto e id de texto esta en la tabla que guarda de manera temporal lo mismo(campos principales) que la
* tabla global dinámica. Esta tabla permite evitar duplicados o más cuando hay varios idiomas a traducir para un mismo objeto.
            READ TABLE lt_main_fields TRANSPORTING NO FIELDS WITH KEY object = ls_main_fields-object
                                                                      obj_name = ls_main_fields-obj_name
                                                                      id_text = ls_main_fields-id_text
                                                                      objtype = ls_main_fields-objtype.
            IF sy-subrc = 0.
* Me guardo la posicion donde se ha encontrado.
              ld_tabix = sy-tabix.
* Los registros de la tabla local y temporal siempre coinciden porque se añaden los mismos datos.
              READ TABLE &lt;tbl&gt; ASSIGNING &lt;wa&gt; INDEX ld_tabix.
            ELSE.
              CLEAR ld_tabix.
* Reasigno la cabecera para limpiar valores previos.
              ASSIGN go_wa_data-&gt;* TO &lt;wa&gt;.
              APPEND ls_main_fields TO lt_main_fields.
* Paso los datos comunes a la cabecera de la tabla de datos
              MOVE-CORRESPONDING ls_main_fields TO &lt;wa&gt;.
            ENDIF.

* Construyo el campo donde se pondra el texto destino
            ld_field_text = get_name_field_text( &lt;ls_tlang&gt; ).
            ASSIGN COMPONENT ld_field_text OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
            IF sy-subrc = 0.
              &lt;field&gt; = &lt;ls_texts&gt;-t_text.

* Si el objeto tiene propuesta de textos se rellena los datos con la propuesta del
* texto. Si no hay texto y hay propuesta se pone el de la propuesta.
* Hay objetos que no tienen propuesta de texto como los formularios.
              IF ld_text_object-&gt;has_proposed_text( ) = abap_true.
                CALL METHOD proposal_text
                  EXPORTING
                    i_tlang        = &lt;ls_tlang&gt;
                    is_texts       = &lt;ls_texts&gt;
                    io_object_text = ld_text_object
                  CHANGING
                    cs_wa          = &lt;wa&gt;.
              ENDIF.

* Si el objeto e id de texto no esta en la tabla temporal, muevo los campos principales
* a la cabecera y añado los datos.
              IF ld_tabix IS INITIAL.
                APPEND &lt;wa&gt; TO &lt;tbl&gt;.
                CLEAR &lt;wa&gt;.
              ENDIF.

            ENDIF.

          ENDLOOP.

* Marco para que el texto de origen no se vuelva a pasar porque ya se ha hecho con el primer idioma.
          ld_primer_source = abap_false.

        ENDIF.
      ENDIF.

    ENDLOOP.
  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="SAVE_DATA" VERSION="1" LANGU="4" DESCRIPT="Save data" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SAVE_DATA" SCONAME="R_RETURN" VERSION="1" LANGU="4" DESCRIPT="Return Parameter" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="BAPIRET2"/>
   <source>METHOD SAVE_DATA.
  FIELD-SYMBOLS &lt;ls_mngt_text&gt; TYPE LINE OF ty_t_mngt_text.


  CLEAR r_return.

* Primero se actualizan los textos en la tabla interna donde contiene los objetos de textos
* de cada objeto.
  update_text_object( ).

* Se recorre la tabla donde contiene la gestion de los propios textos para grabarla.
* Eso si, solo aquellos que se han modificados.
  LOOP AT it_mngt_text ASSIGNING &lt;ls_mngt_text&gt; WHERE data_changed = abap_true.

* Solo se graban los datos modificados.
    CALL METHOD &lt;ls_mngt_text&gt;-oobject-&gt;save_text
      EXCEPTIONS
        error_save = 1
        OTHERS     = 2.

* Cualquier error se almacena en a estructura de salida y se sale.
    IF sy-subrc NE 0.
      r_return = fill_return( i_type = &apos;S&apos;
                              i_number = &apos;006&apos;
                              i_message_v1 = &lt;ls_mngt_text&gt;-object
                              i_message_v2 = &lt;ls_mngt_text&gt;-obj_name ).
      EXIT.
    ENDIF.

  ENDLOOP.

* Si no hay errores en la grabación devuelvo un mensaje indicado del
* éxito de la operación.
  IF r_return IS INITIAL.
    r_return = fill_return( i_type = &apos;S&apos;
                            i_number = &apos;007&apos; ).

* Se vuelven a leer los textos por dos motivos:
* 1) En la SE63, Un campo nuevo en la pantalla de seleccion de un programa que
* referencia al diccionario aparece a traducir. Pero una vez realizada la
* traducción &quot;desaparece&quot;.
* 2) Ajuste de estilos en base a las propuestas.
* Sobretodo por el punto 1 y casos parecidos que puedan ocurrir, lo mejor es leer de nuevo
* y refrescar contenido.
    read_process_texts( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="SET_DATA" VERSION="1" LANGU="4" DESCRIPT="Set data" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SET_DATA" SCONAME="I_T_DATA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD SET_DATA.
  go_it_data = i_t_data.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="SET_PARAMS_SELSCREEN" VERSION="1" LANGU="4" DESCRIPT="Set params of selection screen" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SET_PARAMS_SELSCREEN" SCONAME="I_OLANG" VERSION="1" LANGU="4" DESCRIPT="ISO Language ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SET_PARAMS_SELSCREEN" SCONAME="I_T_TLANG" VERSION="1" LANGU="4" DESCRIPT="Languages" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LXE_TT_LXEISOLANG"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SET_PARAMS_SELSCREEN" SCONAME="I_TRKORR" VERSION="1" LANGU="4" DESCRIPT="Request/Task" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="SET_PARAMS_SELSCREEN" SCONAME="I_DEPTH_REFS" VERSION="1" LANGU="4" DESCRIPT="Depth level references" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="2"/>
   <source>METHOD SET_PARAMS_SELSCREEN.

  d_olang = i_olang. &quot; Idioma origen
  it_tlang = i_t_tlang. &quot; Idioma destino.
  d_trkorr = i_trkorr. &quot; Orden de transporte
  &quot; Nivel de búsqueda de objetos a traducir a partir del objeto principal-
  d_depth_refs = i_depth_refs.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="TRANSPORT_MOD_OBJ" VERSION="1" LANGU="4" DESCRIPT="Transport modified objects" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZTRANS_TOOL" CMPNAME="TRANSPORT_MOD_OBJ" SCONAME="E_RETURN" VERSION="1" LANGU="4" DESCRIPT="Return Parameter" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="BAPIRET2"/>
   <source>METHOD TRANSPORT_MOD_OBJ.
  FIELD-SYMBOLS &lt;ls_mngt_text&gt; TYPE LINE OF ty_t_mngt_text.

  CLEAR e_return.

  IF d_trkorr IS NOT INITIAL.

* Solo se transportan los objetos modificados
    LOOP AT it_mngt_text ASSIGNING &lt;ls_mngt_text&gt; where data_changed = abap_true.
* Una vez grabado en la orden de transporte quito la marca de modificado.
      &lt;ls_mngt_text&gt;-data_changed = abap_false.

* El transporte se realiza desde la propia clase que gestiona los textos.
      CALL METHOD &lt;ls_mngt_text&gt;-oobject-&gt;transport_translate
        EXPORTING
          i_trkorr            = d_trkorr
        EXCEPTIONS
          error_insert_trkorr = 1
          OTHERS              = 2.
      IF sy-subrc &lt;&gt; 0.
        e_return = fill_return( i_type = &apos;W&apos;
                                i_id = sy-msgid
                                i_number = sy-msgno
                                i_message_v1 = sy-msgv1
                                i_message_v2 = sy-msgv2
                                i_message_v3 = sy-msgv3
                                i_message_v4 = sy-msgv4  ).
        EXIT.

      ENDIF.
    ENDLOOP.
    IF sy-subrc = 0.
* Si hay datos y no hay errores saco un mensaje informativo de que todo ha ido bien.
      IF e_return IS INITIAL.
        e_return = fill_return( i_type = &apos;S&apos;
                                i_number = &apos;008&apos;
                                i_message_v1 = d_trkorr ).

* Para evitar que se van acumulando los mismos objetos en la orden, llamo a la funcion
* que ordena y clasifica (elimina duplicados) de la orden/tarea pasada.
* NOTA: Creo que no es necesario porque al hacer pruebas no ha habido duplicado, pero
* lo dejo por si se meten entradas manuales o de otra forma haciendo duplicados.
        CALL FUNCTION &apos;TR_SORT_AND_COMPRESS_COMM&apos;
          EXPORTING
            iv_trkorr                      = d_trkorr
          EXCEPTIONS
            trkorr_not_found               = 1
            order_released                 = 2
            error_while_modifying_obj_list = 3
            tr_enqueue_failed              = 4
            no_authorization               = 5
            OTHERS                         = 6.

      ENDIF.
* Si no se han modificados datos también lo aviso.
    ELSE.
      e_return = fill_return( i_type = &apos;S&apos;
                              i_number = &apos;011&apos; ).

    ENDIF.
  ELSE.
* Si no hay orden se devuelve un mensaje adviertiendolo
    e_return = fill_return( i_type = &apos;S&apos;
                            i_number = &apos;009&apos; ).
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_TOOL" CMPNAME="UPDATE_TEXT_OBJECT" VERSION="1" LANGU="4" DESCRIPT="Update texts to text&apos;s object" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="20140303" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD update_text_object.
  FIELD-SYMBOLS &lt;tbl&gt; TYPE ANY TABLE.
  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;ls_tlang&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;ls_mngt_text&gt; TYPE LINE OF ty_t_mngt_text.
  DATA ls_main_fields TYPE ztrans_main_fields.
  DATA ld_fieldname TYPE fieldname.

  ASSIGN go_it_data-&gt;* TO &lt;tbl&gt;.
  ASSIGN go_wa_data-&gt;* TO &lt;wa&gt;.

  LOOP AT &lt;tbl&gt; ASSIGNING &lt;wa&gt;.

* Paso los datos a una estructura base para poder simplificar el codigo.
    MOVE-CORRESPONDING &lt;wa&gt; TO ls_main_fields.

* Por cada registro leo los lenguajes a traducir para ver cual de ellos ha sido modificado.
    LOOP AT it_tlang ASSIGNING &lt;ls_tlang&gt;.

* Recupero el campo del control del idioma para ver si se ha modificado.
      ld_fieldname = get_name_field_ctrl( &lt;ls_tlang&gt; ).
      ASSIGN COMPONENT ld_fieldname OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
      IF sy-subrc = 0.
        IF &lt;field&gt; = abap_true.

* Quito la marca de campo modificado para que no vuelva a entrar si se cambia otro campo.
          &lt;field&gt; = abap_false.

* Recupero el texto del idioma para informa a la tabla donde están los textos
          ld_fieldname = get_name_field_text( &lt;ls_tlang&gt; ).
          ASSIGN COMPONENT ld_fieldname OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
          IF sy-subrc = 0.

* Busqueda de del objeto del texto
            READ TABLE it_mngt_text ASSIGNING &lt;ls_mngt_text&gt;
                                    WITH TABLE KEY object = ls_main_fields-object
                                                   obj_name = ls_main_fields-obj_name
                                                   tlang = &lt;ls_tlang&gt;.
            IF sy-subrc = 0.

* Indico que los datos se han actualizado para después saber si se han de grabar
              &lt;ls_mngt_text&gt;-data_changed = abap_true.
* Actualizacion
              CALL METHOD &lt;ls_mngt_text&gt;-oobject-&gt;set_text
                EXPORTING
                  i_id_text          = ls_main_fields-id_text
                  i_objtype          = ls_main_fields-objtype
                  i_text             = &lt;field&gt;
                EXCEPTIONS
                  id_text_dont_exist = 1
                  OTHERS             = 2.

            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDLOOP.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZZC_CA02401" VERSION="1" LANGU="E" DESCRIPT="Utilities ITAB dinámicas" UUID="E355EE93C49569F1B9DB0050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <publicSection>class ZZC_CA02401 definition
  public
  final
  create public .

*&quot;* public components of class ZZC_CA02401
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .

  class-methods CREATE_IT_FIELDS_BASE
    importing
      !I_BASE_FIELDS type ANY
      !I_NEW_FIELDS type LVC_T_FCAT
    exporting
      !E_TABLE type ref to DATA
      !E_WA type ref to DATA .
  class-methods CREATE_IT_FROM_FCAT
    importing
      !I_FIELDS type LVC_T_FCAT
    exporting
      !E_TABLE type ref to DATA
      !E_WA type ref to DATA .
  class-methods CREATE_IT_FIELDS_BASE_REF
    importing
      !I_BASE_FIELDS type ref to DATA
      !I_NEW_FIELDS type LVC_T_FCAT
    exporting
      !E_TABLE type ref to DATA
      !E_WA type ref to DATA .
  class-methods GET_COMPONENT_FROM_FCAT
    importing
      !I_FCAT type LVC_T_FCAT
    returning
      value(R_COMPONENTS) type CL_ABAP_STRUCTDESCR=&gt;COMPONENT_TABLE .
  class-methods PIVOT_TABLE
    importing
      !I_PIVOT_PATTERN type STRING
      !I_MOVE_FIELD type STRING
      !I_ITAB_SOURCE type STANDARD TABLE
      !I_PIVOT_FIELD type STRING
    changing
      !C_PIVOT_TABLE type STANDARD TABLE .
  class-methods CREATE_IT_FROM_STRUC
    importing
      !I_STRUC type ANY
    exporting
      !E_TABLE type ref to DATA
      !E_WORKAREA type ref to DATA .
  class-methods CREATE_WA_FROM_STRUC
    importing
      !I_STRUC type ANY
    exporting
      !E_WORKAREA type ref to DATA .</publicSection>
  <protectedSection>*&quot;* protected components of class ZCL_HR_UTILITIES
*&quot;* do not include other source files here!!!
protected section.

  class-data D_TEXT_TYPE type STRING value &apos;TYPE=&apos;. &quot;#EC NOTEXT .

  class-methods GET_NAME_OF_TYPE
    importing
      !I_ABSOLUTE_NAME type ABAP_ABSTYPENAME
    returning
      value(R_NAME_TYPE) type STRING .</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02401
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZZC_CA02401" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZZC_CA02401" CMPNAME="D_TEXT_TYPE" VERSION="1" LANGU="4" DESCRIPT="Literal of type in absolute name" EXPOSURE="1" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" ATTDECLTYP="1" ATTVALUE="&apos;TYPE=&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <method CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE" VERSION="1" LANGU="4" DESCRIPT="Create internat table from some base camps" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="I_BASE_FIELDS" VERSION="1" LANGU="4" DESCRIPT="pointer to the type of data fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="I_NEW_FIELDS" VERSION="1" LANGU="4" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="E_TABLE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="E_WA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131231" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD create_it_fields_base.
  DATA lo_data TYPE REF TO data.

  GET REFERENCE OF i_base_fields INTO lo_data.

  CALL METHOD zzc_ca02401=&gt;create_it_fields_base_ref
    EXPORTING
      i_base_fields = lo_data
      i_new_fields  = i_new_fields
    IMPORTING
      e_table       = e_table
      e_wa          = e_wa.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE_REF" VERSION="1" LANGU="4" DESCRIPT="Create internat table from reference some base camps" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDBY="RODIVA01" CHANGEDON="20140103" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="I_BASE_FIELDS" VERSION="1" LANGU="4" DESCRIPT="pointer to the type of data fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="I_NEW_FIELDS" VERSION="1" LANGU="4" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="E_TABLE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="E_WA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131231" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD create_it_fields_base_ref.

  DATA: le_fcat TYPE lvc_s_fcat,
        lt_fcat TYPE lvc_t_fcat,
        tabname TYPE dd02l-tabname,
        new_line TYPE REF TO data.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA ld_name_type TYPE string.
  DATA ld_dataref TYPE REF TO data.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lt_components_new TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_new_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_new_wa TYPE REF TO cl_abap_structdescr.
  DATA lo_data TYPE REF TO data.
  FIELD-SYMBOLS &lt;component&gt; TYPE LINE OF abap_compdescr_tab.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_data_ref( i_base_fields ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Convierto el fieldcat del campo en componentes
  CALL METHOD get_component_from_fcat
    EXPORTING
      i_fcat       = i_new_fields
    RECEIVING
      r_components = lt_components_new.

* Añado los nuevos componentes a los existentes
  APPEND LINES OF lt_components_new TO lt_components.

* Creo un nuevo tipo de datos con los componentes pasados.
  lo_struct_ref = cl_abap_structdescr=&gt;create( lt_components ).

* Creamos el manejador para la cabecera de la tabla
  CREATE DATA e_wa TYPE HANDLE lo_struct_ref.

* Creo que la nueva tabla interna
  lo_new_tab = cl_abap_tabledescr=&gt;create(
                  p_line_type  = lo_struct_ref
                  p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                  p_unique     = abap_false ).

* Creamos el manejador de la nueva tabla
  CREATE DATA e_table TYPE HANDLE lo_new_tab.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_FCAT" VERSION="1" LANGU="4" DESCRIPT="Create internat table from fieldcatalog" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140103" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_FCAT" SCONAME="I_FIELDS" VERSION="1" LANGU="4" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140103" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_FCAT" SCONAME="E_TABLE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140103" CHANGEDBY="RODIVA01" CHANGEDON="20140103" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_FCAT" SCONAME="E_WA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20140103" CHANGEDBY="RODIVA01" CHANGEDON="20140103" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD CREATE_IT_FROM_FCAT.

  DATA: le_fcat TYPE lvc_s_fcat,
        lt_fcat TYPE lvc_t_fcat,
        tabname TYPE dd02l-tabname,
        new_line TYPE REF TO data.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA ld_name_type TYPE string.
  DATA ld_dataref TYPE REF TO data.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_new_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_new_wa TYPE REF TO cl_abap_structdescr.
  DATA lo_data TYPE REF TO data.
  FIELD-SYMBOLS &lt;component&gt; TYPE LINE OF abap_compdescr_tab.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

* Convierto el fieldcat del campo en componentes
  CALL METHOD get_component_from_fcat
    EXPORTING
      i_fcat       = i_fields
    RECEIVING
      r_components = lt_components.

* Creo un nuevo tipo de datos con los componentes pasados.
  lo_struct_ref = cl_abap_structdescr=&gt;create( lt_components ).

* Creamos el manejador para la cabecera de la tabla
  CREATE DATA e_wa TYPE HANDLE lo_struct_ref.

* Creo que la nueva tabla interna
  lo_new_tab = cl_abap_tabledescr=&gt;create(
                  p_line_type  = lo_struct_ref
                  p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                  p_unique     = abap_false ).

* Creamos el manejador de la nueva tabla
  CREATE DATA e_table TYPE HANDLE lo_new_tab.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_STRUC" VERSION="1" LANGU="4" DESCRIPT="Create internal table from name of structure" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDBY="RODIVA01" CHANGEDON="20140103" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="I_STRUC" VERSION="1" LANGU="4" DESCRIPT="Estructura de datos" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="E_TABLE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="E_WORKAREA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>method CREATE_IT_FROM_STRUC.
  DATA lo_error TYPE REF TO cx_sy_table_creation.
  DATA ld_txt_error TYPE string.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_new_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_new_wa TYPE REF TO cl_abap_structdescr.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_name( i_struc ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Creo un nuevo tipo de datos con los componentes pasados.
  lo_new_wa = cl_abap_structdescr=&gt;create( lt_components ).

* Creo que la nueva tabla interna
  TRY.
      lo_new_tab = cl_abap_tabledescr=&gt;create(
                      p_line_type  = lo_new_wa
                      p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                      p_unique     = abap_false ).

* Creamos el manejador de la nueva tabla
      CREATE DATA e_table TYPE HANDLE lo_new_tab.

* Y su cabecera
      CREATE DATA e_workarea TYPE HANDLE lo_new_wa.


    CATCH cx_sy_table_creation INTO lo_error.
      ld_txt_error = lo_error-&gt;get_text( ).
  ENDTRY.


endmethod.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="CREATE_WA_FROM_STRUC" VERSION="1" LANGU="4" DESCRIPT="Create work area from name of structure" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDBY="RODIVA01" CHANGEDON="20140103" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_WA_FROM_STRUC" SCONAME="I_STRUC" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="CREATE_WA_FROM_STRUC" SCONAME="E_WORKAREA" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>method CREATE_WA_FROM_STRUC.
  DATA lo_error TYPE REF TO cx_sy_struct_creation.
  DATA d_txt_error TYPE string.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_wa TYPE REF TO cl_abap_structdescr.
  FIELD-SYMBOLS &lt;component&gt; TYPE LINE OF abap_compdescr_tab.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_name( i_struc ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Creo un nuevo tipo de datos con los componentes pasados.
  TRY.
      lo_wa = cl_abap_structdescr=&gt;create( lt_components ).

* Creamos el manejador de la nueva tabla
      CREATE DATA e_workarea TYPE HANDLE lo_wa.

    CATCH cx_sy_struct_creation INTO lo_error.
      d_txt_error = lo_error-&gt;get_text( ).

  ENDTRY.



endmethod.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="GET_COMPONENT_FROM_FCAT" VERSION="1" LANGU="4" DESCRIPT="Get components from fieldcat" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDBY="RODIVA01" CHANGEDON="20140103" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="GET_COMPONENT_FROM_FCAT" SCONAME="I_FCAT" VERSION="1" LANGU="4" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="GET_COMPONENT_FROM_FCAT" SCONAME="R_COMPONENTS" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CL_ABAP_STRUCTDESCR=&gt;COMPONENT_TABLE"/>
   <source>METHOD get_component_from_fcat.
  DATA le_component TYPE LINE OF cl_abap_structdescr=&gt;component_table.
  DATA lo_typedescr TYPE REF TO cl_abap_typedescr.
  DATA lo_structdesc TYPE REF TO cl_abap_structdescr.
  DATA ld_type_elem TYPE string.
  DATA ld_dec_elem TYPE i.
  DATA ld_length_elem TYPE i.

  FIELD-SYMBOLS &lt;ls_fcat&gt; TYPE LINE OF lvc_t_fcat.

  CLEAR r_components.

  LOOP AT i_fcat ASSIGNING &lt;ls_fcat&gt;.

    le_component-name = &lt;ls_fcat&gt;-fieldname.

* Obtengo la información del elementos de datos, si esta.
    IF &lt;ls_fcat&gt;-rollname IS NOT INITIAL.
      lo_typedescr = cl_abap_elemdescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).
      ld_type_elem = lo_typedescr-&gt;type_kind.
      ld_dec_elem = lo_typedescr-&gt;decimals.
      ld_length_elem = lo_typedescr-&gt;length.
    ELSE.
      ld_type_elem = &lt;ls_fcat&gt;-inttype.
      ld_dec_elem = &lt;ls_fcat&gt;-decimals.
      ld_length_elem = &lt;ls_fcat&gt;-intlen.
    ENDIF.

    CASE ld_type_elem.

      WHEN cl_abap_elemdescr=&gt;typekind_char.
        le_component-type = cl_abap_elemdescr=&gt;get_c( p_length   = ld_length_elem ).

      WHEN cl_abap_elemdescr=&gt;typekind_packed.
* Obtengo el tipo de datos segun el componente
        le_component-type = cl_abap_elemdescr=&gt;get_p( p_length   = ld_length_elem
                                                      p_decimals = ld_dec_elem ).

      WHEN cl_abap_elemdescr=&gt;typekind_num.
        le_component-type = cl_abap_elemdescr=&gt;get_n( p_length   = ld_length_elem ).

      WHEN cl_abap_elemdescr=&gt;typekind_date.
        le_component-type = cl_abap_elemdescr=&gt;get_d( ).

      WHEN cl_abap_elemdescr=&gt;typekind_string.
        le_component-type = cl_abap_elemdescr=&gt;get_string( ).

      WHEN cl_abap_elemdescr=&gt;typekind_int.
        le_component-type = cl_abap_elemdescr=&gt;get_i( ).

      WHEN cl_abap_elemdescr=&gt;typekind_struct1. &quot; Estructura diccionario

        le_component-type ?= cl_abap_typedescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).

      WHEN cl_abap_elemdescr=&gt;typekind_table. &quot; Tabla interna

        le_component-type ?= cl_abap_typedescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).

*    when cl_abap_elemdescr=&gt;TYPEKIND_struct2.
*    when cl_abap_elemdescr=&gt;TYPEKIND_INT1
*    when cl_abap_elemdescr=&gt;TYPEKIND_CLASS.

    ENDCASE.
    IF le_component IS NOT INITIAL.
      APPEND le_component TO r_components.
      CLEAR le_component.
      FREE lo_typedescr.
    ENDIF.


  ENDLOOP.



*    DATA lo_typedescr  TYPE REF TO cl_abap_elemdescr.
*  DATA le_component TYPE LINE OF cl_abap_structdescr=&gt;component_table.
*
*  FIELD-SYMBOLS &lt;ls_fcat&gt; TYPE LINE OF lvc_t_fcat.
*
*  CLEAR r_components.
*
*  LOOP AT i_fcat ASSIGNING &lt;ls_fcat&gt;.
*
*    le_component-name = &lt;ls_fcat&gt;-fieldname.
*
** Obtengo la información del elementos de datos
*    lo_typedescr ?= cl_abap_elemdescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).
*
**    TYPE_KIND
*case
** Obtengo el tipo de datos segun el componente
*    le_component-type = cl_abap_elemdescr=&gt;get_p( p_length   = lo_typedescr-&gt;length
*                                                  p_decimals = lo_typedescr-&gt;decimals ).
*
*    APPEND le_component TO r_components.
*    CLEAR le_component.
*    FREE lo_typedescr.
*
*  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="GET_NAME_OF_TYPE" VERSION="1" LANGU="4" DESCRIPT="Gets the name of the pointer data type" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="GET_NAME_OF_TYPE" SCONAME="I_ABSOLUTE_NAME" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="GET_NAME_OF_TYPE" SCONAME="R_NAME_TYPE" VERSION="1" LANGU="4" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method GET_NAME_OF_TYPE.
  DATA ld_pos TYPE i.

  CLEAR r_name_type.

* Busco donde empieza el literal TYPE=.
  FIND FIRST OCCURRENCE OF d_text_type IN i_absolute_name MATCH OFFSET ld_pos.
  IF sy-subrc = 0.

* Obtengo el literal desde la posición donde esta el valor DE TYPE=
    r_name_type = i_absolute_name+ld_pos.

* Eliminio el TYPE= para quedarme con el nombre
    REPLACE ALL OCCURRENCES OF d_text_type IN r_name_type WITH space.

  ENDIF.


endmethod.</source>
  </method>
  <method CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" VERSION="1" LANGU="4" DESCRIPT="Pivot table based on another" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDBY="RODIVA01" CHANGEDON="20140103" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="700" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" SCONAME="I_PIVOT_PATTERN" VERSION="1" LANGU="4" DESCRIPT="Pivot field pattern" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" SCONAME="I_MOVE_FIELD" VERSION="1" LANGU="4" DESCRIPT="Field that moves to the pivot fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" SCONAME="I_ITAB_SOURCE" VERSION="1" LANGU="4" DESCRIPT="Table data source" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" SCONAME="I_PIVOT_FIELD" VERSION="1" LANGU="4" DESCRIPT="Pivot field" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZZC_CA02401" CMPNAME="PIVOT_TABLE" SCONAME="C_PIVOT_TABLE" VERSION="1" LANGU="4" DESCRIPT="Pivot table destination" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " AUTHOR="RODIVA01" CREATEDON="20131125" CHANGEDON="00000000" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <source>method PIVOT_TABLE.
  FIELD-SYMBOLS &lt;le_pivot&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_source&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_pivot_field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_move_field&gt; TYPE ANY.
  DATA le_pivot TYPE REF TO data.
  DATA ld_field TYPE string.

* Creo la workarea de la tabla pivote
  CREATE DATA le_pivot LIKE LINE OF c_pivot_table.
  ASSIGN le_pivot-&gt;* TO &lt;le_pivot&gt;.

* Recorro la tabla de origen
  LOOP AT i_itab_source ASSIGNING &lt;le_source&gt;.

* Muevo los campos comunes
    MOVE-CORRESPONDING &lt;le_source&gt; TO &lt;le_pivot&gt;.

* Obtengo el valor del campo que se va pivotar
    ASSIGN COMPONENT i_pivot_field OF STRUCTURE &lt;le_source&gt; TO &lt;le_field&gt;.

    IF sy-subrc = 0.

* Creo el campo donde se pondra el valor en la tabla pivote.
      CONCATENATE &apos;&lt;LE_PIVOT&gt;-&apos; i_pivot_pattern &lt;le_field&gt; INTO ld_field.
      ASSIGN (ld_field) TO &lt;le_pivot_field&gt;.

      IF sy-subrc = 0.

* Obtengo el valor del campo que se va mover su valor al del
* campo de la tabla pivote.
        CONCATENATE &apos;&lt;LE_SOURCE&gt;-&apos; i_move_field INTO ld_field.
        ASSIGN (ld_field) TO &lt;le_move_field&gt;.
        IF sy-subrc = 0.

          &lt;le_pivot_field&gt; = &lt;le_move_field&gt;.
          COLLECT &lt;le_pivot&gt; INTO c_pivot_table.
          CLEAR &lt;le_pivot&gt;.

        ENDIF.
      ENDIF.

    ENDIF.

  ENDLOOP.

endmethod.</source>
  </method>
 </CLAS>
 <INTF CLSNAME="ZIF_REF_DATA" VERSION="1" LANGU="S" DESCRIPT="Data for reference" UUID="E2C624C02F020DF191180050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDON="00000000" CHGDANYON="00000000" UNICODE="X" R3RELEASE="700">
  <types CLSNAME="ZIF_REF_DATA" CMPNAME="TY_LIST_REFS" VERSION="1" LANGU="E" DESCRIPT="Datos generales material" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140219" TYPTYPE="4" SRCROW1="7 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="29 " TYPESRC_LENG="354 " TYPESRC="BEGIN OF ty_list_refs,
            level TYPE i,
            type TYPE trobjtype,
            object TYPE progname,
            internal_name TYPE progname,
            type_ref TYPE trobjtype,
            object_ref TYPE string,
            fullname_ref TYPE string,
            internal_name_ref type progname,
           END OF ty_list_refs
"/>
  <types CLSNAME="ZIF_REF_DATA" CMPNAME="TY_T_LIST_REFS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140219" TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="53 " TYPESRC_LENG="52 " TYPESRC="ty_t_list_refs TYPE STANDARD TABLE OF ty_list_refs
"/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_CLASS" VERSION="1" LANGU="S" DESCRIPT="Class" EXPOSURE="2" STATE="1" EDITORDER="2 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;CLAS&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_DATAELEM" VERSION="1" LANGU="S" DESCRIPT="Data element" EXPOSURE="2" STATE="1" EDITORDER="9 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;DTEL&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_DOMAIN" VERSION="1" LANGU="S" DESCRIPT="Report/modulpool" EXPOSURE="2" STATE="1" EDITORDER="10 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;DOMA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_FUNCTION" VERSION="1" LANGU="S" DESCRIPT="Function" EXPOSURE="2" STATE="1" EDITORDER="4 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;FUNC&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_INTERFACE" VERSION="1" LANGU="S" DESCRIPT="Interface" EXPOSURE="2" STATE="1" EDITORDER="3 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;INTF&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_MESSCLAS" VERSION="1" LANGU="S" DESCRIPT="Message class" EXPOSURE="2" STATE="1" EDITORDER="6 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;MSAG&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_PROGRAM" VERSION="1" LANGU="S" DESCRIPT="Report/modulpool" EXPOSURE="2" STATE="1" EDITORDER="1 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;PROG&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_SEAHLP" VERSION="1" LANGU="S" DESCRIPT="Search help" EXPOSURE="2" STATE="1" EDITORDER="12 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;SHLP&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_SINGLE_MESS" VERSION="1" LANGU="S" DESCRIPT="Single message" EXPOSURE="2" STATE="1" EDITORDER="14 " AUTHOR="RODIVA01" CREATEDON="20140219" CHANGEDON="00000000" ATTDECLTYP="2" ATTVALUE="&apos;MESS&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="700" TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_STRUC" VERSION="1" LANGU="S" DESCRIPT="Structure" EXPOSURE="2" STATE="1" EDITORDER="8 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;STRU&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_TABLE" VERSION="1" LANGU="S" DESCRIPT="Table/structure" EXPOSURE="2" STATE="1" EDITORDER="7 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;TABL&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_TABLTYPE" VERSION="1" LANGU="S" DESCRIPT="Table types" EXPOSURE="2" STATE="1" EDITORDER="11 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;TTYP&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_VIEW" VERSION="1" LANGU="S" DESCRIPT="View" EXPOSURE="2" STATE="1" EDITORDER="13 " AUTHOR="RODIVA01" CREATEDON="20130528" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;VIEW&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_REF_DATA" CMPNAME="DC_TYPE_WEBDYNPRO" VERSION="1" LANGU="S" DESCRIPT="Webdynpro Component" EXPOSURE="2" STATE="1" EDITORDER="5 " AUTHOR="RODIVA01" CREATEDON="20130526" CHANGEDBY="RODIVA01" CHANGEDON="20140216" ATTDECLTYP="2" ATTVALUE="&apos;WDYN&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TROBJTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 </INTF>
 <PROG NAME="ZTRANS_TOOL" VARCL="X" SUBC="1" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140907" VERN="000013" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" SDATE="20140914" STIME="195939" IDATE="20140907" ITIME="190058" UCCHECK="X">
  <textPool>
   <language SPRAS="4">
    <textElement ID="I" KEY="BL1" ENTRY="Search options" LENGTH="14 "/>
    <textElement ID="I" KEY="BL2" ENTRY="Translations options" LENGTH="20 "/>
    <textElement ID="I" KEY="BL3" ENTRY="Other options" LENGTH="13 "/>
    <textElement ID="I" KEY="I01" ENTRY="Only for programs, functions, class and DDIC:" LENGTH="45 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Transport options." LENGTH="19 "/>
    <textElement ID="I" KEY="T01" ENTRY="Transport changes" LENGTH="17 "/>
    <textElement ID="I" KEY="T02" ENTRY="Selective transport" LENGTH="19 "/>
    <textElement ID="R" ENTRY="Tool for translate objects" LENGTH="26 "/>
    <textElement ID="S" KEY="P_DREFS" ENTRY="        Depth level References" LENGTH="30 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_OLANG" ENTRY="        Source language" LENGTH="23 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
    <textElement ID="S" KEY="S_TLANG" ENTRY="        Target languages" LENGTH="24 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="I" KEY="BL1" ENTRY="Search options" LENGTH="14 "/>
    <textElement ID="I" KEY="BL2" ENTRY="Translations options" LENGTH="20 "/>
    <textElement ID="I" KEY="BL3" ENTRY="Other options" LENGTH="13 "/>
    <textElement ID="I" KEY="I01" ENTRY="Only for programs, functions, class and DDIC:" LENGTH="45 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Transport options." LENGTH="19 "/>
    <textElement ID="I" KEY="T01" ENTRY="Transport changes" LENGTH="17 "/>
    <textElement ID="I" KEY="T02" ENTRY="Selective transport" LENGTH="19 "/>
    <textElement ID="R" ENTRY="Tool for translate objects" LENGTH="26 "/>
    <textElement ID="S" KEY="P_DREFS" ENTRY="        Depth level References" LENGTH="30 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_OLANG" ENTRY="        Source language" LENGTH="23 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
    <textElement ID="S" KEY="S_TLANG" ENTRY="        Target languages" LENGTH="24 "/>
   </language>
   <language SPRAS="F">
    <textElement ID="I" KEY="BL2" ENTRY="sdsdsd" LENGTH="20 "/>
    <textElement ID="S" KEY="P_TTEX" ENTRY="        FRANCES" LENGTH="29 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
   </language>
   <language SPRAS="L">
    <textElement ID="I" KEY="BL1" ENTRY="Search options" LENGTH="14 "/>
    <textElement ID="I" KEY="BL2" ENTRY="Translations options" LENGTH="20 "/>
    <textElement ID="I" KEY="BL3" ENTRY="Other options" LENGTH="13 "/>
    <textElement ID="I" KEY="I01" ENTRY="Only for programs, functions, class and DDIC:" LENGTH="45 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Transport options." LENGTH="19 "/>
    <textElement ID="I" KEY="T01" ENTRY="Transport changes" LENGTH="17 "/>
    <textElement ID="I" KEY="T02" ENTRY="Selective transport" LENGTH="19 "/>
    <textElement ID="R" ENTRY="Tool for translate objects" LENGTH="26 "/>
    <textElement ID="S" KEY="P_DREFS" ENTRY="        Depth level References" LENGTH="30 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_OLANG" ENTRY="        Source language" LENGTH="23 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
    <textElement ID="S" KEY="S_TLANG" ENTRY="        Target languages" LENGTH="24 "/>
   </language>
   <language SPRAS="P">
    <textElement ID="S" KEY="P_TTEX" ENTRY="        portgues" LENGTH="29 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
   </language>
   <language SPRAS="S">
    <textElement ID="I" KEY="BL1" ENTRY="Opciones de búsqueda" LENGTH="20 "/>
    <textElement ID="I" KEY="BL2" ENTRY="Opciones de traducción" LENGTH="22 "/>
    <textElement ID="I" KEY="BL3" ENTRY="Otras opciones" LENGTH="14 "/>
    <textElement ID="I" KEY="I01" ENTRY="Solo para programas, funciones, clases y DDIC." LENGTH="46 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Opciones de transporte" LENGTH="22 "/>
    <textElement ID="I" KEY="T01" ENTRY="Transportar modificaciones" LENGTH="26 "/>
    <textElement ID="I" KEY="T02" ENTRY="Transporte selectivo" LENGTH="20 "/>
    <textElement ID="R" ENTRY="herramienta traducción" LENGTH="70 "/>
    <textElement ID="S" KEY="P_DREFS" ENTRY="        Nivel de profundidad de referencias" LENGTH="43 "/>
    <textElement ID="S" KEY="P_OLANG" ENTRY="        Idioma origen" LENGTH="23 "/>
    <textElement ID="S" KEY="S_TLANG" ENTRY="        Idioma destino" LENGTH="24 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
   </language>
   <language SPRAS="W">
    <textElement ID="I" KEY="BL1" ENTRY="Search options" LENGTH="14 "/>
    <textElement ID="I" KEY="BL2" ENTRY="Translations options" LENGTH="20 "/>
    <textElement ID="I" KEY="BL3" ENTRY="Other options" LENGTH="13 "/>
    <textElement ID="I" KEY="I01" ENTRY="Only for programs, functions, class and DDIC:" LENGTH="45 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Transport options." LENGTH="19 "/>
    <textElement ID="I" KEY="T01" ENTRY="Transport changes" LENGTH="17 "/>
    <textElement ID="I" KEY="T02" ENTRY="Selective transport" LENGTH="19 "/>
    <textElement ID="R" ENTRY="Tool for translate objects" LENGTH="26 "/>
    <textElement ID="S" KEY="P_DREFS" ENTRY="        Depth level References" LENGTH="30 "/>
    <textElement ID="S" KEY="P_OBJECT" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_OLANG" ENTRY="        Source language" LENGTH="23 "/>
    <textElement ID="S" KEY="P_ONAME" ENTRY="D       ." LENGTH="19 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="D       ." LENGTH="20 "/>
    <textElement ID="S" KEY="S_TLANG" ENTRY="        Target languages" LENGTH="24 "/>
   </language>
  </textPool>
  <dynpros>
   <dynpro PROG="ZTRANS_TOOL" DNUM="9000" FNUM="9000" BZMX="0 " BZBR="0 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="27 " NOCO="120 " VALP="0 " CUAN="G" SPRA="E" DGEN="20140301" TGEN="173313" DTEXT="Show data">
    <dynprofield FNAM="D_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE status_9000.
  MODULE alv_view.
*
PROCESS AFTER INPUT.

  MODULE salir AT EXIT-COMMAND.

  MODULE user_command_9000.</dynproflowsource>
   </dynpro>
  </dynpros>
  <pfstatus>
   <pfstatus_sta CODE="P9000" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="Status dynprop 9000"/>
   <pfstatus_fun CODE="%EX" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
   <pfstatus_fun CODE="BACK" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Back"/>
   <pfstatus_fun CODE="BU" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
   <pfstatus_fun CODE="RW" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="BACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="BU" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="RW" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="%EX" FUNNO="001"/>
   <pfstatus_set STATUS="P9000" FUNCTION="%EX"/>
   <pfstatus_set STATUS="P9000" FUNCTION="BACK"/>
   <pfstatus_set STATUS="P9000" FUNCTION="BU"/>
   <pfstatus_set STATUS="P9000" FUNCTION="RW"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="Status dynpro 9000"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="Status dynpro 9000"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="D" INT_NOTE="Status dynpro 9000"/>
   <pfstatus_tit CODE="T9000" TEXT="Translate &amp; &amp;"/>
  </pfstatus>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTRANS_TOOL
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp; Description: tool for translate objects
*&amp; Author: Iván Rodrigo(Stratesys) 23/12/2013
*&amp;---------------------------------------------------------------------*

REPORT  ztrans_tool MESSAGE-ID ztrans_tool.

INCLUDE ztrans_tool_top.
INCLUDE ztrans_tool_c01.

*----------------------------------------------------------------------*
* Selection screen
*----------------------------------------------------------------------*
SELECTION-SCREEN BEGIN OF BLOCK bl1 WITH FRAME TITLE text-bl1.
PARAMETERS p_object TYPE trobjtype OBLIGATORY.
PARAMETERS p_oname TYPE tadir-obj_name.
SELECTION-SCREEN END OF BLOCK bl1.

SELECTION-SCREEN BEGIN OF BLOCK bl2 WITH FRAME TITLE text-bl2.
PARAMETERS p_olang TYPE lxe_log-targlng OBLIGATORY.
SELECT-OPTIONS: s_tlang FOR lxe_log-targlng OBLIGATORY NO INTERVALS.
SELECTION-SCREEN END OF BLOCK bl2.

SELECTION-SCREEN BEGIN OF BLOCK bl3 WITH FRAME TITLE text-bl3.
PARAMETERS p_trkorr TYPE e070-trkorr.
SELECTION-SCREEN SKIP.
SELECTION-SCREEN COMMENT /1(49) text1.
PARAMETERS p_drefs TYPE i DEFAULT 2.
SELECTION-SCREEN END OF BLOCK bl3.

*----------------------------------------------------------------------*
* initialization
*----------------------------------------------------------------------*
INITIALIZATION.
  PERFORM evt_initialization.

*----------------------------------------------------------------------*
* Events of screen
*----------------------------------------------------------------------*
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_object.
  PERFORM f4_object.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_olang.
  PERFORM f4_olang.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR s_tlang-low.
  PERFORM f4_spras.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_trkorr.
  PERFORM f4_trkorr.

AT SELECTION-SCREEN ON s_tlang. &quot; validacion idioma destino
  PERFORM check_tlang.

AT SELECTION-SCREEN ON BLOCK bl1.
  PERFORM check_bl1.

AT SELECTION-SCREEN ON BLOCK bl3.
  PERFORM check_trkorr.

AT SELECTION-SCREEN OUTPUT.
  PERFORM pbo_ps.

*----------------------------------------------------------------------*
* Select data
*----------------------------------------------------------------------*
START-OF-SELECTION.

* Inicializacion de datos
  PERFORM init_data.

* Se transfieren los datos de la pantalla de seleccion a la clase
  PERFORM set_params_selscreen.

* Lectura de textos del objeto
  PERFORM load_object_texts.

*----------------------------------------------------------------------*
* Display data
*----------------------------------------------------------------------*
END-OF-SELECTION.
  IF &lt;it_datos&gt; IS NOT INITIAL.
    PERFORM show_data.
  ELSE.
    MESSAGE s005.
  ENDIF.

  INCLUDE ztrans_tool_f01.
  INCLUDE ztrans_tool_o01.
  INCLUDE ztrans_tool_i01.</source>
 </PROG>
 <PROG NAME="ZTRANS_TOOL_C01" VARCL="X" SUBC="I" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140301" VERN="    1" LEVL="700" RMAND="200" RLOAD="E" SDATE="20140208" STIME="154916" IDATE="20140208" ITIME="154916" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include Z_CA02701_C01" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_CA02701_C01
*&amp;---------------------------------------------------------------------*
CLASS lcl_event_alv DEFINITION.
  PUBLIC SECTION.
    METHODS:
      handle_data_changed
         FOR EVENT data_changed OF cl_gui_alv_grid
             IMPORTING er_data_changed,
    handle_toolbar
        FOR EVENT toolbar OF cl_gui_alv_grid
            IMPORTING e_object e_interactive,
    handle_user_command
        FOR EVENT user_command OF cl_gui_alv_grid
            IMPORTING e_ucomm,
    handle_menu_button
        FOR EVENT menu_button OF cl_gui_alv_grid
            IMPORTING e_object e_ucomm.
ENDCLASS.                    &quot;lcl_event_alv DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_event_alv IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_alv IMPLEMENTATION.
  METHOD handle_data_changed.
    PERFORM data_changed CHANGING er_data_changed.
  ENDMETHOD.                    &quot;handle_data_changed

  METHOD handle_toolbar.
    PERFORM toolbar_alv CHANGING e_object e_interactive.
  ENDMETHOD.                    &quot;handle_toolbar
  METHOD handle_user_command.
    perform user_command_toolbar CHANGING e_ucomm.
  ENDMETHOD.                    &quot;handle_user_command
  METHOD handle_menu_button.
    PERFORM menu_toolbar CHANGING e_object e_ucomm.
  ENDMETHOD.                    &quot;handle_menu_button
ENDCLASS.                    &quot;lcl_event_alv IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZTRANS_TOOL_F01" VARCL="X" SUBC="I" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140914" VERN="000022" LEVL="700" RSTAT="K" RMAND="200" RLOAD="E" SDATE="20140914" STIME="195939" IDATE="20140914" ITIME="195939" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include Z_CA02701_F01" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
***INCLUDE Z_CA02701_F01 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  EVT_INITIALIZATION
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM evt_initialization .
  DATA ls_allowed_object LIKE LINE OF it_allowed_object.

* Se instancia la clase que gestionara todo la herramientra de traduccion.
  CREATE OBJECT go_proces.

* Se recupera los objetos permitidos en base a las clases de componentes
* parametrizadas.
  it_allowed_object = go_proces-&gt;get_allowed_objects( ).

* Idioma fuente por defecto
  CALL FUNCTION &apos;LXE_T002_CHECK_LANGUAGE&apos;
    EXPORTING
      r3_lang    = sy-langu
    IMPORTING
      o_language = p_olang.

* Indico que los refrescos de los ALV no se moverán de filas y columna
  et_stable-row = abap_true.
  et_stable-col = abap_true.

* Nombre del programa para variantes.
  et_variant-report = sy-cprog.
ENDFORM.                    &quot; EVT_INITIALIZATION
*&amp;---------------------------------------------------------------------*
*&amp;      Form  F4_OBJECT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f4_object .
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;OBJECT&apos;
      window_title    = &apos;Allowed Plugins&apos;
      dynpprog        = sy-repid
      dynpnr          = &apos;1000&apos;
      dynprofield     = &apos;P_OBJECT&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_allowed_object
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
ENDFORM.                    &quot; F4_OBJECT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_BL1
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM check_bl1 .
  IF p_object IS INITIAL.
    MESSAGE e001.
  ELSE.
* Compruebo si el objeto es valido
    READ TABLE it_allowed_object TRANSPORTING NO FIELDS
                                 WITH KEY object = p_object.
    IF sy-subrc = 0.
* Compruebo si el objeto existe
      IF go_proces-&gt;check_obj_2_trans( i_object = p_object i_obj_name = p_oname ) = abap_false.
        MESSAGE e004 WITH p_object p_oname.
      ENDIF.
    ELSE.
      MESSAGE e012 WITH p_object.
    ENDIF.

  ENDIF.
ENDFORM.                    &quot; CHECK_BL1
*&amp;---------------------------------------------------------------------*
*&amp;      Form  LOAD_OBJECT_TEXTS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM load_object_texts .

* Se leen los textos del objeto y sus componentes.
  go_proces-&gt;load_object_texts( ).

* Se recuperan el texto del objeto con sus componentes.
  go_it_data = go_proces-&gt;get_data( ).
  ASSIGN go_it_data-&gt;* TO &lt;it_datos&gt;.

ENDFORM.                    &quot; LOAD_OBJECT_TEXTS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  F4_OLANG
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM f4_olang .
  CALL FUNCTION &apos;LXE_T002_SELECT_LANGUAGE&apos;
    EXPORTING
      dynpprog        = &apos;Z_CA02701&apos;
      dynpnr          = &apos;1000&apos;
      dynpfield       = &apos;P_OLANG&apos;
    IMPORTING
      language        = p_olang
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      no_selection    = 3
      OTHERS          = 4.

ENDFORM.                    &quot; F4_OLANG
*&amp;---------------------------------------------------------------------*
*&amp;      Form  PBO_PS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM pbo_ps .
* Texto informativo para el campo de niveles de profundidad.
  text1 = text-i01.

  LOOP AT SCREEN.
    CASE screen-name.
* El idioma de origen, objeto a traducir y la orden se desactiva la entrada de datos.
* Se usará el matchcode para hacerlo.
* Se hace para que usen la ayuda para búsqueda y no se introduzcan cosas que no deben.
      WHEN &apos;P_OLANG&apos; OR &apos;P_TRKORR&apos;.
        screen-input = 0.
    ENDCASE.
    MODIFY SCREEN.
  ENDLOOP.
ENDFORM.                    &quot; PBO_PS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  F4_SPRAS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f4_spras .

  CALL FUNCTION &apos;LXE_T002_SELECT_LANGUAGE&apos;
    EXPORTING
      dynpprog        = &apos;Z_CA02701&apos;
      dynpnr          = &apos;1000&apos;
      dynpfield       = &apos;S_TLANG-LOW&apos;
    IMPORTING
      language        = s_tlang-low
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      no_selection    = 3
      OTHERS          = 4.

ENDFORM.                    &quot; F4_SPRAS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_tlang
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM check_tlang.

* Se borra el idioma de origen en el ranges de idiomas de destino.
* no tiene sentido poner los mismos.
  DELETE s_tlang WHERE low = p_olang.

* La búsqueda por patrones no esta permitida, y no se puede marcar la opción
* de exclusion.
  LOOP AT s_tlang TRANSPORTING NO FIELDS WHERE option = &apos;CP&apos;
                                               OR sign = &apos;E&apos;.
    EXIT.
  ENDLOOP.
  IF sy-subrc = 0.
    MESSAGE e002.
  ELSE.

    IF s_tlang-low IS NOT INITIAL.
      CALL FUNCTION &apos;LXE_T002_CHECK_LANGUAGE&apos;
        EXPORTING
          language           = s_tlang-low
        EXCEPTIONS
          language_not_in_cp = 1
          unknown            = 2
          OTHERS             = 3.
      IF sy-subrc &gt; 1.
        MESSAGE e003(lxe_trans) WITH s_tlang-low. &quot; Idioma no existe.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot;check_tlang
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_PARAMS_SELSCREEN
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM set_params_selscreen .
  DATA lt_tlang TYPE lxe_tt_lxeisolang.

* El ranges de los idiomas se pasa a una tabla normal
  LOOP AT s_tlang.
    APPEND s_tlang-low TO lt_tlang.
  ENDLOOP.

  CALL METHOD go_proces-&gt;set_params_selscreen
    EXPORTING
      i_olang      = p_olang
      i_t_tlang    = lt_tlang
      i_trkorr     = p_trkorr
      i_depth_refs = p_drefs.

ENDFORM.                    &quot; SET_PARAMS_SELSCREEN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SHOW_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM show_data .
  CALL SCREEN 9000.
ENDFORM.                    &quot; SHOW_DATA
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DATA_CHANGED
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM data_changed  CHANGING ps_data_changed TYPE REF TO cl_alv_changed_data_protocol.
  FIELD-SYMBOLS &lt;ls_modif&gt; TYPE lvc_s_modi.
  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;lt_field_style&gt; TYPE lvc_t_styl.
  FIELD-SYMBOLS &lt;ls_field_style&gt; TYPE LINE OF lvc_t_styl.
  DATA ld_fieldname TYPE fieldname.
  DATA ls_field_style TYPE LINE OF lvc_t_styl.


  LOOP AT ps_data_changed-&gt;mt_mod_cells ASSIGNING &lt;ls_modif&gt;.
* En el primer registro se marca que los datos han sido modificados
    AT FIRST.
      d_datos_modif = abap_true.
    ENDAT.
* Registro cada vez que se modifica una fila.
    AT NEW row_id.
* Leo el registro modificado.
      READ TABLE &lt;it_datos&gt; ASSIGNING &lt;wa&gt; INDEX &lt;ls_modif&gt;-row_id.
    ENDAT.

* Paso el texto modificado al campo que toca.
    ASSIGN COMPONENT &lt;ls_modif&gt;-fieldname OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
    IF sy-subrc = 0.
      &lt;field&gt; = &lt;ls_modif&gt;-value.
    ENDIF.

* Pongo el nombre del campo en una variable para despues cambiarlo para actualizar
* el campo de control.
    ld_fieldname = &lt;ls_modif&gt;-fieldname.

* Para actualizar el campo de control tengo que reemplazar el texto del nombre del campo
* por el de control.
    REPLACE go_proces-&gt;dc_field_txt_lang IN ld_fieldname
            WITH go_proces-&gt;dc_field_ctrl_lang.

* Actualizo el campo de control
    ASSIGN COMPONENT ld_fieldname OF STRUCTURE &lt;wa&gt; TO &lt;field&gt;.
    IF sy-subrc = 0.
      &lt;field&gt; = abap_true.
    ENDIF.

* Cambio el color del campo de texto. No se puede actualizar directamente el estilo
* en la tabla porque ira bien para el primer ENTER. Pero si luego se modifica y se vuelve
* a pulsar ENTER se pierde el estilo de la primera modificacion. Vamos, que solo
* hay color para los últimos cambios.
    CALL METHOD ps_data_changed-&gt;modify_style
      EXPORTING
        i_row_id    = &lt;ls_modif&gt;-row_id
        i_fieldname = &lt;ls_modif&gt;-fieldname
        i_style     = go_proces-&gt;dc_style_text_changed.

  ENDLOOP.

ENDFORM.                    &quot; DATA_CHANGED
*&amp;---------------------------------------------------------------------*
*&amp;      Form  BUTTONS_EXCLUDE_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM buttons_exclude_alv .
*it_excluding
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_append_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_copy TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_copy_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_cut TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_delete_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_insert_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_move_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_paste TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_paste_new_row TO it_excluding.
  APPEND cl_gui_alv_grid=&gt;mc_fc_loc_undo  TO it_excluding.
ENDFORM.                    &quot; BUTTONS_EXCLUDE_ALV
*&amp;---------------------------------------------------------------------*
*&amp;      Form  save_data
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM save_data.
  DATA ls_return TYPE bapiret2.

  IF d_datos_modif = abap_true.

* Se pasa los datos a la clase de control
    go_proces-&gt;set_data( go_it_data ).

* Se graban los datos
    ls_return = go_proces-&gt;save_data( ).

    CASE ls_return-type.
* Los mensajes de error se muestran como informativos pero de tipo error.
      WHEN &apos;E&apos; OR &apos;X&apos; OR &apos;A&apos;.
        MESSAGE ID ls_return-id TYPE &apos;S&apos;
                       NUMBER ls_return-number
                       WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4
                       DISPLAY LIKE &apos;E&apos;.
      WHEN OTHERS.
* Una vez grabado sin error se marca que los datos no están modificados.
        d_datos_modif = abap_false.

        MESSAGE ID ls_return-id TYPE ls_return-type
                       NUMBER ls_return-number
                       WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4.
    ENDCASE.

* Refresco los datos para que se van los cambios en la tabla interna de datos.
* No es necesario recuperar los datos porque ya se han hecho con anterioridad a través
* de punteros. Por lo que todo se haga en la clase o programa se ve reflejando en ambos sitios
* sin necesidad de traspasar de nuevo los datos. Viva los punteros :-)
    CALL METHOD go_alv-&gt;refresh_table_display( EXPORTING is_stable = et_stable ).

  ELSE.
    MESSAGE s010.
  ENDIF.

ENDFORM.                    &quot;save_data
*&amp;---------------------------------------------------------------------*
*&amp;      Form  F4_TRKORR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM f4_trkorr .
  DATA ld_order TYPE trkorr.
  DATA ld_task TYPE trkorr.
  DATA ld_trkorr TYPE trkorr.
  DATA lt_dyntab TYPE STANDARD TABLE OF dynpread.
  DATA ls_dyntab TYPE dynpread.

  CALL FUNCTION &apos;TR_ORDER_CHOICE_CORRECTION&apos;
    EXPORTING
      iv_category = &apos;SYST&apos;
    IMPORTING
      ev_order    = ld_order
      ev_task     = ld_task
    EXCEPTIONS
      OTHERS      = 3.
  IF sy-subrc = 0.

* La tarea si, se devuelve, tiene más prioridad. Esto se hace para
* operacion en la orden que se harán al transportar (como clasificar y comprimir).
    IF ld_task IS NOT INITIAL.
      ld_trkorr = ld_task.
    ELSEIF ld_order IS NOT INITIAL.
      ld_trkorr = ld_order.
    ENDIF.

* Si hay orden actualizo el campo de la pantalla.
    IF ld_trkorr IS NOT INITIAL.
      ls_dyntab-fieldname = &apos;P_TRKORR&apos;.
      ls_dyntab-fieldvalue = ld_trkorr.
      APPEND ls_dyntab TO lt_dyntab.

      CALL FUNCTION &apos;DYNP_VALUES_UPDATE&apos;
        EXPORTING
          dyname               = &apos;Z_CA02701&apos;
          dynumb               = &apos;1000&apos;
        TABLES
          dynpfields           = lt_dyntab
        EXCEPTIONS
          invalid_abapworkarea = 1
          invalid_dynprofield  = 2
          invalid_dynproname   = 3
          invalid_dynpronummer = 4
          invalid_request      = 5
          no_fielddescription  = 6
          undefind_error       = 7
          OTHERS               = 8.
    ENDIF.

  ENDIF.
ENDFORM.                    &quot; F4_TRKORR
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_TRKORR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM check_trkorr .
  FIELD-SYMBOLS &lt;ls_req_head&gt; TYPE trwbo_request_header.
  DATA ld_trfunction TYPE e070-trfunction.
  DATA lt_req_head TYPE trwbo_request_headers.
  DATA lt_req TYPE trwbo_requests.
  DATA ld_order TYPE e070-trkorr.

  IF p_trkorr IS NOT INITIAL.
* Se las tareas de las ordenes para ver si hay alguna valida.
    CALL FUNCTION &apos;TR_READ_REQUEST_WITH_TASKS&apos;
      EXPORTING
        iv_trkorr          = p_trkorr
      IMPORTING
        et_request_headers = lt_req_head
        et_requests        = lt_req
      EXCEPTIONS
        invalid_input      = 1
        OTHERS             = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

* Se mira si hay alguna tarea valida para el usuario.
    LOOP AT lt_req_head ASSIGNING &lt;ls_req_head&gt; WHERE trfunction = &apos;S&apos;
                                                      AND trstatus = &apos;D&apos;
                                                      AND as4user = sy-uname.
      EXIT.
    ENDLOOP.
    IF sy-subrc = 0.
      p_trkorr = &lt;ls_req_head&gt;-trkorr.
    ELSE.
* En caso de no haberla se lee la primera posicion se indique la orden padre para leer
* algunos datos y crear la tarea.
      LOOP AT lt_req_head ASSIGNING &lt;ls_req_head&gt; WHERE strkorr IS NOT INITIAL.
        EXIT.
      ENDLOOP.
      IF sy-subrc = 0.

        CALL FUNCTION &apos;TRINT_INSERT_NEW_COMM&apos;
          EXPORTING
            wi_kurztext       = &lt;ls_req_head&gt;-as4text
            wi_trfunction     = &apos;S&apos;
            iv_username       = sy-uname
            wi_strkorr        = &lt;ls_req_head&gt;-strkorr
            wi_client         = sy-mandt
          IMPORTING
            we_trkorr         = p_trkorr
          EXCEPTIONS
            no_systemname     = 1
            no_systemtype     = 2
            no_authorization  = 3
            db_access_error   = 4
            file_access_error = 5
            enqueue_error     = 6
            number_range_full = 7
            invalid_input     = 8
            OTHERS            = 9.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot; CHECK_TRKORR
*&amp;---------------------------------------------------------------------*
*&amp;      Form  TOOLBAR_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM toolbar_alv CHANGING ps_object TYPE REF TO cl_alv_event_toolbar_set
                          ps_interactive TYPE char01.
  DATA ls_toolbar  TYPE stb_button.

* Se añade un separador para separar los botones estándar de los propios.
  CLEAR ls_toolbar.
  MOVE 3 TO ls_toolbar-butn_type.
  APPEND ls_toolbar TO ps_object-&gt;mt_toolbar.

  CLEAR ls_toolbar.
  MOVE &apos;TRANSPORT&apos; TO ls_toolbar-function.
  MOVE icon_transport TO ls_toolbar-icon.
  MOVE text-q01 TO ls_toolbar-quickinfo.
  MOVE 1 TO ls_toolbar-butn_type. &quot; Menu + opcion por defecto
  IF p_trkorr IS NOT INITIAL.
    MOVE space TO ls_toolbar-disabled.
  ELSE.
    MOVE abap_true TO ls_toolbar-disabled .
  ENDIF.
  APPEND ls_toolbar TO ps_object-&gt;mt_toolbar.

ENDFORM.                    &quot; TOOLBAR_ALV
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MENU_TOOLBAR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

FORM menu_toolbar  CHANGING ps_object TYPE REF TO cl_ctmenu
                            ps_ucomm TYPE sy-ucomm.

* Se desplega el menú en base a la opción escogida.
  CASE ps_ucomm.
    WHEN &apos;TRANSPORT&apos;.
      ps_object-&gt;add_function( fcode = &apos;TRANSPORT&apos;
                               text = text-t01 &quot; Transport changes
                               icon =  icon_import_transport_request ).

      ps_object-&gt;add_function( fcode = &apos;TRANS_OBJ&apos;
                               text = text-t02 &quot; Selective transport
                               icon  = icon_transport_proposal
                               disabled = abap_true ).
  ENDCASE.
ENDFORM.                    &quot; MENU_TOOLBAR
*&amp;---------------------------------------------------------------------*
*&amp;      Form  USER_COMMAND_TOOLBAR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM user_command_toolbar  CHANGING ps_ucomm TYPE sy-ucomm.

  CASE ps_ucomm.
    WHEN &apos;TRANSPORT&apos;. &quot; Transport all objects
      PERFORM transport_mod_obj.
    WHEN &apos;TRANS_OBJ&apos;. &quot; Selective transport
  ENDCASE.

ENDFORM.                    &quot; USER_COMMAND_TOOLBAR
*&amp;---------------------------------------------------------------------*
*&amp;      Form  TRANSPORT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM transport_mod_obj .
  DATA ls_return TYPE bapiret2.

  CALL METHOD go_proces-&gt;transport_mod_obj
    IMPORTING
      e_return = ls_return.

  CASE ls_return-type.
* Los errores se muestran como informativo pero de tipo error, de esta
* manera no se sale del programa.
    WHEN &apos;E&apos; OR &apos;X&apos; OR &apos;A&apos;.
      MESSAGE ID ls_return-id TYPE &apos;S&apos; NUMBER ls_return-number
             WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4
             DISPLAY LIKE &apos;E&apos;.
    WHEN OTHERS.
      MESSAGE ID ls_return-id TYPE ls_return-type NUMBER ls_return-number
           WITH ls_return-message_v1 ls_return-message_v2 ls_return-message_v3 ls_return-message_v4.
  ENDCASE.

ENDFORM.                    &quot; TRANSPORT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM init_data .
* Los datos no se han modificado.
  d_datos_modif = abap_false.
ENDFORM.                    &quot; INIT_DATA</source>
 </PROG>
 <PROG NAME="ZTRANS_TOOL_I01" VARCL="X" SUBC="I" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140301" VERN="    1" LEVL="700" RSTAT="K" RMAND="200" RLOAD="E" SDATE="20140209" STIME="123136" IDATE="20140209" ITIME="123136" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include Z_CA02701_I01" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
***INCLUDE Z_CA02701_I01 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  SALIR  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE salir INPUT.
  SET SCREEN 0. LEAVE SCREEN.
ENDMODULE.                 &quot; SALIR  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_9000  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_9000 INPUT.
  DATA ld_valid TYPE sap_bool.
  CALL METHOD go_alv-&gt;check_changed_data( IMPORTING e_valid = ld_valid ).
  IF ld_valid = abap_true.
    CASE d_okcode.
      WHEN &apos;BU&apos;.
        PERFORM save_data.
    ENDCASE.
  ENDIF.
ENDMODULE.                 &quot; USER_COMMAND_9000  INPUT</source>
 </PROG>
 <PROG NAME="ZTRANS_TOOL_O01" VARCL="X" SUBC="I" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140902" VERN="000025" LEVL="700" RSTAT="K" RMAND="200" RLOAD="E" SDATE="20140902" STIME="215941" IDATE="20140902" ITIME="215941" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include Z_CA02701_O01" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
***INCLUDE Z_CA02701_O01 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_9000  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_9000 OUTPUT.
  SET PF-STATUS &apos;P9000&apos;.
  SET TITLEBAR &apos;T9000&apos; WITH go_proces-&gt;d_object go_proces-&gt;d_obj_name.

ENDMODULE.                 &quot; STATUS_9000  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ALV_VIEW  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE alv_view OUTPUT.
  DATA ld_repid TYPE sy-repid.
  DATA ld_dynnr TYPE sy-dynnr.
  DATA lt_fcat TYPE lvc_t_fcat.

  IF go_container IS NOT BOUND.

    ld_repid = sy-repid.
    ld_dynnr = sy-dynnr.

    CREATE OBJECT go_container
      EXPORTING
        repid = ld_repid
        dynnr = ld_dynnr
        side  = cl_gui_docking_container=&gt;dock_at_left
        ratio = 95.

* Creo el ALV
    CREATE OBJECT go_alv
      EXPORTING
        i_parent = go_container.

* Botones del ALV a excluir
    PERFORM buttons_exclude_alv.

* Layout
    et_layout-col_opt = abap_true.
    et_layout-cwidth_opt = abap_true.
    et_layout-stylefname = go_proces-&gt;dc_field_style.

* Catalogo de campos
    lt_fcat = go_proces-&gt;get_fcat( ).

* La verificación cuando se haga enter
    CALL METHOD go_alv-&gt;register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=&gt;mc_evt_enter. &quot; mc_evt_modified

* Mostrar campos
    CALL METHOD go_alv-&gt;set_table_for_first_display
      EXPORTING
        i_bypassing_buffer   = &apos;X&apos;
        is_layout            = et_layout
        is_variant           = et_variant
        it_toolbar_excluding = it_excluding
      CHANGING
        it_fieldcatalog      = lt_fcat
        it_outtab            = &lt;it_datos&gt;.
*        it_filter            = it_filters.

* Activo el estado de edicion del ALV
    CALL METHOD go_alv-&gt;set_ready_for_input
      EXPORTING
        i_ready_for_input = 1.

* Activo el evento de validación de datos
    CREATE OBJECT go_event_receiver_alv.
    SET HANDLER go_event_receiver_alv-&gt;handle_data_changed FOR go_alv.
    SET HANDLER go_event_receiver_alv-&gt;handle_user_command FOR go_alv.
    SET HANDLER go_event_receiver_alv-&gt;handle_toolbar FOR go_alv.
    SET HANDLER go_event_receiver_alv-&gt;handle_menu_button FOR go_alv.

* Lanzo el evento para construir/modificar la barra de herramientas del ALV
    go_alv-&gt;set_toolbar_interactive( ).

  ELSE.
    CALL METHOD go_alv-&gt;refresh_table_display( EXPORTING is_stable = et_stable ).
  ENDIF.
ENDMODULE.                 &quot; ALV_VIEW  OUTPUT</source>
 </PROG>
 <PROG NAME="ZTRANS_TOOL_TOP" VARCL="X" SUBC="I" CNAM="RODIVA01" CDAT="20140301" UNAM="RODIVA01" UDAT="20140301" VERN="000011" LEVL="700" RMAND="200" RLOAD="E" SDATE="20140301" STIME="173427" IDATE="20140301" ITIME="173427" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include Z_CA02701_TOP" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_CA02701_TOP
*&amp;---------------------------------------------------------------------*
*----------------------------------------------------------------------*
* Dictionary tables
*----------------------------------------------------------------------*
TABLES: tadir, t002, lxe_log.

*----------------------------------------------------------------------*
* Types
*----------------------------------------------------------------------*
TYPE-POOLS: trwbo, icon, abap.

*----------------------------------------------------------------------*
* Variables
*----------------------------------------------------------------------*
DATA go_proces TYPE REF TO ztrans_tool. &quot; Clase que gestiona el proceso
DATA go_it_data TYPE REF TO data. &quot; Tabla interna con los datos.
FIELD-SYMBOLS &lt;it_datos&gt; TYPE table. &quot; Puntero a la tabla interna de datos
data d_datos_modif type sap_bool. &quot; Controla si los datos han cambiado.

*----------------------------------------------------------------------*
* Internal tables
*----------------------------------------------------------------------*
* Objetos que pueden ser traducidos
DATA it_allowed_object TYPE tr_object_texts.

*----------------------------------------------------------------------*
* Declaración para los ALV
*----------------------------------------------------------------------*

* Catalogo de campos de la vista
DATA it_fieldcat TYPE lvc_t_fcat.

* Catalogo de campos clave de la vista
DATA it_fieldcat_key TYPE lvc_t_fcat.

* Lista de campos para las ordenes de transporte
DATA it_fieldlist TYPE ddfields.

* Funciones de la barra del ALV que se excluiran
DATA it_excluding TYPE ui_functions.
DATA et_stable TYPE lvc_s_stbl.
DATA et_layout TYPE lvc_s_layo.
DATA et_variant TYPE disvariant.
DATA it_filters TYPE lvc_t_filt.
DATA go_alv TYPE REF TO cl_gui_alv_grid.
DATA go_container TYPE REF TO cl_gui_docking_container.
CLASS lcl_event_alv DEFINITION DEFERRED.
DATA go_event_receiver_alv TYPE REF TO lcl_event_alv.
DATA d_okcode TYPE syucomm.</source>
 </PROG>
 <TABL TABNAME="ZTRANS_MAIN_FIELDS" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Main fields to the data table" AUTHCLASS="00" AS4USER="RODIVA01" AS4DATE="20140303" AS4TIME="223312" PROZPUFF="000" EXCLASS="4">
  <dd09l AS4VERS="0000" SCHFELDANZ="000" AS4DATE="00000000" AS4TIME="000000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0001" ROLLNAME="TROBJTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0002" ROLLNAME="SOBJ_NAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="OBJTYPE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="LXEOBJTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="LXEOBJTYPE" ROUTPUTLEN="000000" HEADLEN="27" SCRLEN1="10" SCRLEN2="17" SCRLEN3="27" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" ENTITYTAB="LXE_ATTOB" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type of Translation Object" REPTEXT="Type of Translation Object" SCRTEXT_S="ObjectType" SCRTEXT_M="Translation OType" SCRTEXT_L="Type of Translation Object" DOMNAME3L="LXEOBJTYPE" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="ID_TEXT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="LXETEXTKEY" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="LXECHAR32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Text Key" REPTEXT="Text Key" SCRTEXT_S="Key" SCRTEXT_M="Text Key" SCRTEXT_L="Text Key" DOMNAME3L="LXECHAR32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="TXT_OLANG" DDLANGUAGE="E" POSITION="0005" ROLLNAME="ZTRANS_OLANG" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRGE" MASKLEN="0000" DDTEXT="Source language" REPTEXT="Source language" SCRTEXT_S="Src. Lang." SCRTEXT_M="Source language" SCRTEXT_L="Source language" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_MAIN_FIELDS" FIELDNAME="FIELD_STYLE" DDLANGUAGE="E" POSITION="0006" ROLLNAME="LVC_T_STYL" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="ALV Control: Style Table for Cells" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
 <TABL TABNAME="ZTRANS_TEXTS" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Texts pairs" AUTHCLASS="00" AS4USER="RODIVA01" AS4DATE="20140303" AS4TIME="222217" PROZPUFF="000" EXCLASS="4">
  <dd09l AS4VERS="0000" SCHFELDANZ="000" AS4DATE="00000000" AS4TIME="000000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="LXE_PCX_S1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Text Pairs" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="TEXTKEY" DDLANGUAGE="E" POSITION="0002" ROLLNAME="LXETEXTKEY" ADMINFIELD="1" INTTYPE="C" INTLEN="000064" DOMNAME="LXECHAR32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Text Key" REPTEXT="Text Key" SCRTEXT_S="Key" SCRTEXT_M="Text Key" SCRTEXT_L="Text Key" DOMNAME3L="LXECHAR32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="S_TEXT" DDLANGUAGE="E" POSITION="0003" ROLLNAME="LXEUNITLIN" ADMINFIELD="1" INTTYPE="C" INTLEN="000510" DOMNAME="LXEUNITLIN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="36" DTELMASTER="D" DATATYPE="CHAR" LENG="000255" OUTPUTLEN="000255" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Translation Unit for Short Text (Line)" REPTEXT="Translation Unit for Short Text (Line)" SCRTEXT_S="Unit: ST" SCRTEXT_M="Short Text Unit" SCRTEXT_L="Short Text Translation Unit (Line)" DOMNAME3L="LXEUNITLIN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="T_TEXT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="LXEUNITLIN" ADMINFIELD="1" INTTYPE="C" INTLEN="000510" DOMNAME="LXEUNITLIN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="36" DTELMASTER="D" DATATYPE="CHAR" LENG="000255" OUTPUTLEN="000255" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Translation Unit for Short Text (Line)" REPTEXT="Translation Unit for Short Text (Line)" SCRTEXT_S="Unit: ST" SCRTEXT_M="Short Text Unit" SCRTEXT_L="Short Text Translation Unit (Line)" DOMNAME3L="LXEUNITLIN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="UNITMLT" DDLANGUAGE="E" POSITION="0005" ROLLNAME="LXEUNITMLT" ADMINFIELD="1" INTTYPE="X" INTLEN="000004" DOMNAME="LXEUNITLTH" ROUTPUTLEN="000000" HEADLEN="38" SCRLEN1="10" SCRLEN2="20" SCRLEN3="38" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" MASK="  INT4E" MASKLEN="0000" DDTEXT="Maximum Length of Translation Unit" REPTEXT="Maximum Length of Translation Unit" SCRTEXT_S="Max.length" SCRTEXT_M="Maximum Unit Length" SCRTEXT_L="Maximum Length of Translation Unit" DOMNAME3L="LXEUNITLTH" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="UPPCASE" DDLANGUAGE="E" POSITION="0006" ROLLNAME="LXEUPPCASE" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="BOOLE" ROUTPUTLEN="000000" HEADLEN="14" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Only Upper Case Allowed" REPTEXT="Upper Case" SCRTEXT_S="Upper Case" SCRTEXT_M="Upper Case" SCRTEXT_L="Only Upper Case" DOMNAME3L="BOOLE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
  <dd03p TABNAME="ZTRANS_TEXTS" FIELDNAME="OBJTYPE" DDLANGUAGE="E" POSITION="0007" ROLLNAME="LXEOBJTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="LXEOBJTYPE" ROUTPUTLEN="000000" HEADLEN="27" SCRLEN1="10" SCRLEN2="17" SCRLEN3="27" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" ENTITYTAB="LXE_ATTOB" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type of Translation Object" REPTEXT="Type of Translation Object" SCRTEXT_S="ObjectType" SCRTEXT_M="Translation OType" SCRTEXT_L="Type of Translation Object" DOMNAME3L="LXEOBJTYPE" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000"/>
 </TABL>
 <MSAG ARBGB="ZTRANS_TOOL" MASTERLANG="E" RESPUSER="RODIVA01" LASTUSER="RODIVA01" LDATE="20140302" LTIME="132041" STEXT="Message for translation tool">
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="000" TEXT="&amp; &amp; &amp; &amp;"/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="001" TEXT="Select a object to translate."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="002" TEXT="Search of pattern or exclusion not allowed."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="003" TEXT="Introduced languages don&apos;t exist."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="004" TEXT="The &amp; &amp; don&apos;t exist."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="005" TEXT="No data found."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="006" TEXT="Error save the text of object &amp; &amp;."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="007" TEXT="Data saved."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="008" TEXT="Objects added in the transport order &amp;."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="009" TEXT="No transport request."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="010" TEXT="No data changed."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="011" TEXT="Please, saved before the changes."/>
  <t100 SPRSL="4" ARBGB="ZTRANS_TOOL" MSGNR="012" TEXT="Object &amp; not allowed."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="000" TEXT="&amp; &amp; &amp; &amp;"/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="001" TEXT="Select a object to translate."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="002" TEXT="Search of pattern or exclusion not allowed."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="003" TEXT="Introduced languages don&apos;t exist."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="004" TEXT="The &amp; &amp; don&apos;t exist."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="005" TEXT="No data found."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="006" TEXT="Error save the text of object &amp; &amp;."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="007" TEXT="Data saved."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="008" TEXT="Objects added in the transport order &amp;."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="009" TEXT="No transport request."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="010" TEXT="No data changed."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="011" TEXT="Please, saved before the changes."/>
  <t100 SPRSL="E" ARBGB="ZTRANS_TOOL" MSGNR="012" TEXT="Object &amp; not allowed."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="000" TEXT="&amp; &amp; &amp; &amp;"/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="001" TEXT="Select a object to translate."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="002" TEXT="Search of pattern or exclusion not allowed."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="003" TEXT="Introduced languages don&apos;t exist."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="004" TEXT="The &amp; &amp; don&apos;t exist."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="005" TEXT="No data found."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="006" TEXT="Error save the text of object &amp; &amp;."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="007" TEXT="Data saved."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="008" TEXT="Objects added in the transport order &amp;."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="009" TEXT="No transport request."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="010" TEXT="No data changed."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="011" TEXT="Please, saved before the changes."/>
  <t100 SPRSL="L" ARBGB="ZTRANS_TOOL" MSGNR="012" TEXT="Object &amp; not allowed."/>
  <t100 SPRSL="S" ARBGB="ZTRANS_TOOL" MSGNR="001" TEXT="Seleccione un objeto a traducir"/>
  <t100 SPRSL="S" ARBGB="ZTRANS_TOOL" MSGNR="002" TEXT="Búsqueda de patrones no permitida."/>
  <t100 SPRSL="S" ARBGB="ZTRANS_TOOL" MSGNR="004" TEXT="El &amp; &amp; no existe en la TADIR"/>
  <t100 SPRSL="S" ARBGB="ZTRANS_TOOL" MSGNR="010" TEXT="No hay datos modificados."/>
  <t100 SPRSL="S" ARBGB="ZTRANS_TOOL" MSGNR="012" TEXT="Objeto &amp; no permitido."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="000" TEXT="&amp; &amp; &amp; &amp;"/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="001" TEXT="Select a object to translate."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="002" TEXT="Search of pattern or exclusion not allowed."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="003" TEXT="Introduced languages don&apos;t exist."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="004" TEXT="The &amp; &amp; don&apos;t exist."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="005" TEXT="No data found."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="006" TEXT="Error save the text of object &amp; &amp;."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="007" TEXT="Data saved."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="008" TEXT="Objects added in the transport order &amp;."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="009" TEXT="No transport request."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="010" TEXT="No data changed."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="011" TEXT="Please, saved before the changes."/>
  <t100 SPRSL="W" ARBGB="ZTRANS_TOOL" MSGNR="012" TEXT="Object &amp; not allowed."/>
  <t100t SPRSL="4" ARBGB="ZTRANS_TOOL" STEXT="Message for translation tool"/>
  <t100t SPRSL="E" ARBGB="ZTRANS_TOOL" STEXT="Message for translation tool"/>
  <t100t SPRSL="L" ARBGB="ZTRANS_TOOL" STEXT="Message for translation tool"/>
  <t100t SPRSL="W" ARBGB="ZTRANS_TOOL" STEXT="Message for translation tool"/>
 </MSAG>
 <DTEL ROLLNAME="ZTRANS_OLANG" DDLANGUAGE="E" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Source language" REPTEXT="Source language" SCRTEXT_S="Src. Lang." SCRTEXT_M="Source language" SCRTEXT_L="Source language" AUTHCLASS="00" AS4USER="RODIVA01" AS4DATE="20140301" AS4TIME="175427" DTELMASTER="E" DATATYPE="STRG" LENG="000000" DECIMALS="000000" OUTPUTLEN="000000">
  <tpara/>
 </DTEL>
 <CLAS CLSNAME="ZTRANS_CMP_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="Components: Programs/Class plugin" UUID="E3A15E980A127AF196370050563FEE45" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDBY="RODIVA01" CHANGEDON="00000000" CHGDANYON="00000000" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="700" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZTRANS_CMP">
  <publicSection>class ZTRANS_CMP_PROGRAM definition
  public
  inheriting from ZTRANS_CMP
  final
  create public .

*&quot;* public components of class ZTRANS_CMP_PROGRAM
*&quot;* do not include other source files here!!!
public section.

  methods GET_COMPONENTS
    redefinition .
  methods GET_OBJECTS_TYPE
    redefinition .</publicSection>
  <protectedSection>*&quot;* protected components of class ZTRANS_CMP_PROGRAM
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
  <privateSection>*&quot;* private components of class ZZC_CA02704
*&quot;* do not include other source files here!!!
private section.</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZTRANS_CMP_PROGRAM" REFCLSNAME="ZTRANS_CMP" VERSION="1" STATE="1" AUTHOR="RODIVA01" CREATEDON="20140301" CHANGEDON="00000000">
   <redefinition CLSNAME="ZTRANS_CMP_PROGRAM" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_COMPONENTS"/>
   <redefinition CLSNAME="ZTRANS_CMP_PROGRAM" REFCLSNAME="ZTRANS_CMP" VERSION="1" MTDNAME="GET_OBJECTS_TYPE"/>
  </inheritance>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_COMPONENTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_components.
  FIELD-SYMBOLS &lt;ls_refs&gt; TYPE LINE OF zif_ref_data=&gt;ty_t_list_refs.
  DATA lt_refs TYPE zif_ref_data=&gt;ty_t_list_refs.
  DATA lo_refs TYPE REF TO zcl_ref_object.
  DATA ls_components TYPE LINE OF ty_t_components.

  CLEAR e_components.

  CREATE OBJECT lo_refs.

  CALL METHOD lo_refs-&gt;search_refs
    EXPORTING
      i_object              = d_obj_name
      i_type                = d_object
      i_level_depth_max     = et_params_comp-depth_refs
    IMPORTING
      e_refs                = lt_refs
    EXCEPTIONS
      type_object_not_valid = 1
      OTHERS                = 2.

  IF sy-subrc = 0.

* Leo el primer registro de la tabla de ref
* Se pasa el componente pasado
    ls_components-object = d_object.

* Obtengo el nombre interno, necesario para encontrar las traduccion en clases.
    CALL METHOD zcl_ref_source=&gt;get_internal_name
      EXPORTING
        i_object              = d_obj_name
        i_type                = d_object
      IMPORTING
        e_internal_name       = ls_components-obj_name
      EXCEPTIONS
        type_object_not_valid = 1
        OTHERS                = 2.
    IF sy-subrc NE 0.
      ls_components-obj_name = d_obj_name.
    ENDIF.
    APPEND ls_components TO e_components.

* Los includes de los programas no se procesan ya que los textos pertenecen al programa padre.
    DELETE lt_refs WHERE type = &apos;PROG&apos;
                         AND fullname_ref CS &apos;\IC:&apos;.


* Se pasan las referencia del objeto a la tabla de componentes
* Uso la estructura base para añadir los campos comunes. Esto simplifica el codigo.
    LOOP AT lt_refs ASSIGNING &lt;ls_refs&gt;.
      ls_components-object = &lt;ls_refs&gt;-type_ref.



* Devuelvo el nombre interno porque para funciones y clases se ha de usar el interno para recuperar los extos.
      IF &lt;ls_refs&gt;-internal_name_ref IS NOT INITIAL.
        ls_components-obj_name = &lt;ls_refs&gt;-internal_name_ref.
      ELSE.
        ls_components-obj_name = &lt;ls_refs&gt;-object_ref.
      ENDIF.
      APPEND ls_components TO e_components.
    ENDLOOP.

    FREE lo_refs.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZTRANS_CMP" CMPNAME="GET_OBJECTS_TYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD GET_OBJECTS_TYPE.

* Programas
  APPEND &apos;PROG&apos; TO r_objects.
* Clases
  APPEND &apos;CLAS&apos; TO r_objects.

ENDMETHOD.</source>
  </method>
 </CLAS>
</nugget>
